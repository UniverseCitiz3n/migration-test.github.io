var store = [{
        "title": "Autopilot pt. 1",
        "excerpt":"Intro   Hi there! For some time I‚Äôve been thinking about creating a few posts on starting your own Windows Autopilot small lab. This lab is Hyper-V based so prepare your strongest hardware or dust off your servers and enjoy!   Microsoft 365 tenant   Windows Autopilot is cloud solution which purpose is to bring devices into management state over the Internet.   This requires‚Ä¶ü•Åü•Å‚Ä¶Microsoft 365 tenant with licenses!   THE BEST way to get your own POC/sandbox/place where you can break things is to request Microsoft 365 Developer Program üôå   Simply, go here and fill-out the from!   You will get Microsoft 365 E5 instant sandbox with:      25 user licenses for development purposes   Fully loaded sample data with 16 sample users, user data, and content to help you model your solutions.   Easy access to pre-provisioned core Microsoft 365 workloads and capabilities (Windows not included), including:            All Office 365 apps       Everything you need for Power Platform development       Office 365 Advanced Threat Protection       Advanced analytics with Power BI       Enterprise Mobility + Security (EMS) for compliance and information protection üëàüëà       Azure Active Directory for building advanced identity and access management solutions           All this and more for free!   Where is a catch? Such sandbox has renewable expiration period of 90 days.      How to renew it? You need to create some activity within environment. From my experience it does not have to be anything complicated. I had periods of time when I signed-in to tenant clicked through some stuff once in 3 months and it was sufficient üòÅ   Windows and Office 365 deployment lab kit   Second part of your sandbox is Hyper-v lab. The labs in the kit cover using Microsoft Endpoint Configuration Manager, Desktop Analytics (which is now deprecated), the Office Customization Tool, OneDrive, Windows Autopilot, and more.   What you get in the kit:      Windows 10/11 Enterprise   Windows 7 Enterprise   Microsoft Endpoint Configuration Manager, Version 2107   Windows Assessment and Deployment Kit for Windows 11/10   Microsoft Deployment Toolkit   Microsoft BitLocker Administration and Monitoring   Windows Server 2022/2019   Microsoft SQL Server   This environment has 90 days evaluation period and more or less after that time Microsoft releases updated version of the kit.   To get your own setup go here.   Summary   Now you have all the tools to create, test, break and learn!   Checkout next part of this series to see how to slightly improve your lab.   See you in next! üòâ üß†   ","categories": ["Autopilot"],
        "tags": ["Intune","Microsoft365"],
        "url": "http://localhost:4000/autopilot/2022-01-05-Autopilot-Start/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Autopilot pt. 2",
        "excerpt":"Intro   Welcome to the second part of the Autopilot lab. If you missed the first part or whish to jump further please visit Autopilot collection üöÄ.   In this part I will show you quick fix and improvement to Hyper-V lab provided by Microsoft.   TBC   See you in next! üòâ üß†   ","categories": ["Autopilot"],
        "tags": ["Intune","Microsoft365","Hyper-V"],
        "url": "http://localhost:4000/autopilot/2022-01-08-Autopilot-HyperVLab/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Integrating Lansweeper and Office 365",
        "excerpt":"Intro   Lansweeper is a great IT assets management tool! This new feature was introduced in version 7.1. Scanning is done using Powershell cmdlets and provides you with data of organizations, domains, users, admins, password enforcement settings, groups, licenses, mailbox lists, ActiveSync devices and more. So it is nice to have it all in one console.    Prerequisites   There are a few things you should do and check before implementing this feature. Requirements:      Lansweeper 7.1 or above - I recommend installing the newest update which is 7.2 it was released on 7th of September   Azure AD account -  which credentials will be used for scanning. Also this account cannot be included in MFA policy in your organization   If you restrictions to view Azure AD by users you may need to exclude this scanning account from policy.   Account should have assigned permissions to use Exchange Online cmdlets. But we will get back to that later.   Beside those there are requirements which should apply to on-prem scanning server:      Your Lansweeper scanning server must be able to access the Internet to connect to your Office 365 environment. A connection is made to outlook.office365.com.   Your Lansweeper scanning server must be running Windows 7 or a more recent operating system.   Your Lansweeper scanning server must have a 64-bit architecture.   Your Lansweeper scanning server must have PowerShell version 5. If you only just installed this PowerShell version, make sure to reboot your machine.   Your Lansweeper scanning server‚Äôs WinRM client configuration must have Basic authentication enabled.   Your Lansweeper scanning server must be configured to allow scripts that are signed by a trusted publisher.   If you meet those requirements you will can proceed with configuration!   Scanning credentials   First things first, create account in your AD or Azure AD if you are not using hybrid environment. Funny thing, in official Lansweeper knowledge base they are recommending that the account you will be using to scan Office 365 should have tenant Global Administrator role assigned!üòÇ  I think it is giant over-exaggeration!  Lets be smarter than that‚Ä¶ As I mentioned before, if you applied any restrictions to Azure AD you need to add this account to built-in Azure AD role Directory readers or your custom role if you have.  This will be enough to fill tabs: Summary, Groups, Licenses, Users with data. The rest of the tabs (Mailboxes, Contacts, Active Sync Devices) is processed by Exchange Online cmdlets and to handle that you will need to create Management Role.   To do that you need to connect to Exchange Online with privileged credentials and then run this code:   New-ManagementRole \"LanSweeperRole\" -Parent \"Mail Recipients\" Get-ManagementRoleEntry \"LanSweeperRole\\*\" |`     Where-Object { $PSItem.Name -notlike 'Get-mailbox' -or $PSItem.Name -notlike 'Get-mailContact' -or $PSItem.Name -notlike 'Get-MobileDevice' } |`     ForEach-Object { Remove-ManagementRoleEntry -Identity \"$($PSItem.id)\\$($PSItem.name)\" -Confirm:$false } New-RoleGroup 'LanSweeperScan' -Role 'LanSweeperRole' -Member 'sa_Lansweeper_O365'   Thanks to that I‚Äôve created new role which allows users assigned to group ‚ÄòLanSweeperScan‚Äô to run only those three cmdlets: Get-Mailbox, Get-MailContact, Get-ActiveSyncDevice. And that will be enough to get things done!    Configurations in Lansweeper   Now that we‚Äôve met all requirements we can proceed with configurations in Lansweeper Web Console. Those last steps are the easiest in whole process!     Go to scanning targets    Click on ‚ÄòAdd Scanning Target‚Äô. You will see new window where you will be able to provide created scanning credentials    And you are ready to go   Pro tip   If you would like to check scanning credentials before configuring feature in production you can use great test tool which is located in Lansweeper installation on your server. [‚Ä¶]\\Lansweeper\\Service\\Lansweeper.TestTools.App    See you in next! üòâ üß†  ","categories": ["Lansweeper"],
        "tags": ["Lansweeper","PowerShell","Office 365","Exchange","Azure","Active Directory"],
        "url": "http://localhost:4000/lansweeper/LS-Office365/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Integrating Lansweeper and Microsoft Intune",
        "excerpt":"Intro   Welcome in second (out of three) Lansweeper integration series. If you would like to know how to integrate LS with different services like Office 365 feel free to check this out:      Integrating Lansweeper and Office 365   In this post I will go through process of integrating LS with Microsoft Intune. If you are reading this I presume that you know Lansweeper itself and I‚Äôm almost certain that you know Intune too but there is not harm in providing you with some basics.   Lansweeper - IT assets management tool and network inventory software. It scans, discovers and inventories all Windows, Linus, Mac-OS workstations and IP-addressable devices.LS collects wide variety of data about devices and provides user-friendly interface to go through collected endpoints parameters.   Microsoft Intune - cutting edge cloud-based service in the enterprise mobility management developed by Microsoft. It allows to manage workstations over Internet without them being connected to company infrastructure. It helps you keep you corporate data protected by control the way your workforce accesses and shares it. And finally it helps you to ensure that devices and apps are compliant with company security requirements.   What does Lansweeper fetch from Intune? Well, everything it can: device name, enrollment date and compliance state, MAC address, manufacturer, model, carrier, OS version, storage, IMEI, MEID, serial number, user, info on whether the device is jail broken, installed applications and more.      Excited? So let‚Äôs begin!   Prerequisites   There are a few things you should do and check before implementing this feature. Requirements:      Lansweeper 7.1 or above - I recommend installing the newest update which is 7.2 it was released on 7th of September   Azure AD account -  which credentials will be used for scanning. Also this account cannot be included in MFA policy in your organization   Security group in Active Directory assigned to Intune Role - Read Only Operator   You must provide Lansweeper with the application ID of an application that can read Intune devices from the Microsoft Graph API   Spare Intune license - I will get back to that later in post   Beside those there are requirements which should apply to on-prem scanning server and you can find them in first post in series - Integrating Lansweeper and Office 365   If you meet those requirements you will can proceed with configuration!   Scanning credentials   Firstly create in your AD/AAD service account which will be used in scanning credentials. You will find in official Lansweeper knowledge base that this account should have Intune Administrator role assigned.   Well, you can do this and if you don‚Äôt mind having such high privileged account in you tenant. My proposition is to assign read only operator role and also you will need the most basic Intune license which costs around 3 Euro per month.   For me it not seems like the end of the world paying this money and you will be able to sleep better üòÄ.   Next step is setting Intune application in AzureAD. Log into your Azure tenant, select the Azure Active Directory menu on the left, the App registrations section within this menu and hit the New registration button.      Provide name for you application and hit the Register and the botton.   Then go to the Authentication menu of your application, set the default client type setting to Yes and hit Save.      Last step is to provide application with permissions to Microsoft Graph. To do this go to API permissions menu of your application and hit the Add a permission button.      Select Microsoft Graph from the list of available APIs in the resulting popup      Submit DeviceManagementManagedDevices. Read. All in the search box, tick the permission in the search results and hit Add permissions at the bottom of the page.      After choosing permissions you need high privileged account to grant admin consent      And that is all in the matter of scanning credentials!   Configurations in Lansweeper   Now that we‚Äôve met all requirements we can proceed with configurations in Lansweeper Web Console. Those last steps are the easiest in whole process!      Go to scanning targets         Click on ‚ÄòAdd Scanning Target‚Äô. You will see new window where you will be able to provide created scanning credentials      And you are ready to go   Pro tip   If you would like to check scanning credentials before configuring feature in production you can use great test tool which is located in Lansweeper installation on your server. [‚Ä¶]\\Lansweeper\\Service\\Lansweeper. TestTools. App      See you in next! üòâ üß†  ","categories": ["Lansweeper"],
        "tags": ["Lansweeper","Intune","Azure","Active Directory"],
        "url": "http://localhost:4000/lansweeper/LS-Intune/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "How to use Selenium via Powershell",
        "excerpt":"Intro   Nobody likes clicking on over and over the same thing just to get your job done. That is why I‚Äôve started to automate things üòÑ. Everything goes smoothly if service provider gives you tools like APIs, Powershell cmdlets, WebHooks, etc. But how to get things done on website if those tools are no good? You can use Selenium! And what is Selenium? It is code driven testing framework which automates browser. With it help I were able to speed-up new project creation process in our company Jira which in this case (our Jira‚Äôs version is somewhere 6) I were not able to use REST API.   Let me reveal some of this magic ‚ú®   Getting started   What you will need is Webdriver.dll you can grab some from here or download directly from NuGet and extract it with 7-zip. Secondly you will need browser driver. I‚Äôm using Chrome Driver but there are drivers for Firefox, Opera, Edge, Safari. You can get Chrome driver here. Lastly after you pick your driver be sure that you have installed browser itself üòÖ. It‚Äôs the best to put .dll and .exe in the same folder to which you will be reaching in code.  Time for some code.   Starting web driver   Firstly you need to load assembly to your workspace and executable to environmental path variable.   $PathToFolder = 'C:\\Temp\\Selenium' [System.Reflection.Assembly]::LoadFrom(\"{0}\\WebDriver.dll\" -f $PathToFolder) if ($env:Path -notcontains \";$PathToFolder\" ) {     $env:Path += \";$PathToFolder\" }   Done.  Now you can lunch Selenium driven browser from your Powershell console!      Like that:   $ChromeOptions = New-Object OpenQA.Selenium.Chrome.ChromeOptions $ChromeOptions.AddArgument('start-maximized') $ChromeOptions.AcceptInsecureCertificates = $True  $ChromeDriver = New-Object OpenQA.Selenium.Chrome.ChromeDriver($ChromeOptions) $ChromeDriver.Url = 'https://universecitiz3n.github.io'   You can see in this code that I‚Äôm creating two objects:      ChromeOptions -   this is a class which helps you set your browser preferences. I‚Äôve declared two options; Fullscreen is nice and second option is to save few lines of code when you bump into:      Yeah be sure that you trust site even though its cert expired!!      ChromeDriver -   this creates new instance of webdriver the moment you create object from this class your browser will come to life ‚ö°Ô∏è.   Things you can do   Making you browser open specified site comes to this   $ChromeDriver.Url = 'https://yourwebsite.com'   You must remember to put link in https:// format.   How about clicking on stuff? Well you need to know ID of element or its position. Your best friend for that is Inspect option provided by browser.      One you have opened Inspect tab you will be able to identify web objects and with right Selenium command manipulate them! These are available methods within webdriver that you can use   #The ones I'm used to use $ChromeDriver.FindElementById('') $ChromeDriver.FindElementByXPath('')  #The rest $ChromeDriver.FindElementByClassName('') $ChromeDriver.FindElementByCssSelector('') $ChromeDriver.FindElementByLinkText('') $ChromeDriver.FindElementByName('') $ChromeDriver.FindElementByPartialLinkText('') $ChromeDriver.FindElementByTagName('')   If website is well designed you should be able to get IDs of objects and user FindElementById      In this case ID for Log in button is wp-submit and to click it just run code like:   $ChromeDriver.FindElementById('wp-submit').Click()   Now, what if some element has no ID? For me XPath works the best. Getting XPath value is simple as      and now you can easily click on anything! Just like that:   $ChromeDriver.FindElementByXPath('//*[@id=\"main\"]/div[2]/div[1]/article/h2/a').Click()      Next big thing is to fill boxes with your text and again what you should start with is to fetch ID or XPath of textbox. If you got this you can pass you text to box simply with:   $ChromeDriver.FindElementsById('user_login').SendKeys('yourlogin@domain.com')      Isn‚Äôt it great? üòÅ  I hope that I‚Äôve opened new door of possibilities before you will be brave enough to fiddle with things that Selenium brings! Manual clicking with mouse is boring! üòé   Pro tip   Be sure after running scripts to properly clean your workspace. To do that paste at the end of your script those   $ChromeDriver.close() $ChromeDriver.quit()   If you won‚Äôt do that browser will not correctly dump temporary files which are created after staring webdriver session.  You can find those files in %LocalAppData%\\Temp      See you in next! üòâ üß†  ","categories": ["Selenium"],
        "tags": ["Selenium","Powershell","Automation"],
        "url": "http://localhost:4000/selenium/Selenium-Powershell/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Browser automation with Selenium - use cases",
        "excerpt":"Intro   In this post I am going to show you some use cases of Selenium in automating browser where API is unavailable or not enough. Before we continue please be sure to check first steps in using this testing framework via Powershell - How to use Selenium via Powershell  üòâ   ‚Ä¶ok, done reading? Let‚Äôs roll!   Signing in   What I‚Äôm about to show you might not be the most clever way to pass credentials at websites but it works in controlled environment. Just like in introduction most of the times we have:      So we need to fill username, password and captcha but there is no trick to that.   $Credential = Get-Credentials $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Credential.Password) $PlainPass = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)  $ChromeDriver.FindElementsById('user_login').SendKeys($Credential.UserName) Start-Sleep 1 $ChromeDriver.FindElementsById('user_pass').SendKeys($PlainPass) Start-Sleep 30 #Wait for user to pass captcha $ChromeDriver.FindElementsById('wp-submit').Click()   I‚Äôve created PSCredential variable and to be able to fill in password field we need to decipher it. Without those steps you will be entering System.Security.SecureString which obviously is not your password, or is it? ü§î  Regarding captcha the only way is to pause script until user passes the test.   Tables on sites   Great example of table which required help of Selenium is permission table in Confluence Spaces.       I were not able to change them using module ConfluencePS but thanks to that code it became piece of cake! In this example I‚Äôm adding new group to permissions list and ticking checkboxes to resemble Admin permissions   #Adding new group to permissions list $ChromeDriver.FindElementById(\"groups-to-add-autocomplete\").SendKeys(\"Conf_GroupName_Admin\") Start-Sleep -Milliseconds 500 #Clicking Add button $ChromeDriver.FindElementByXPath('//*[@id=\"space-tools-body\"]/form/div/div[3]/input[2]').Click() #Loop ticking checkboxes for ($i = 4; $i -le '13'; $i++) {     $ChromeDriver.FindElementByXPath(\"//*[@id='gPermissionsTable']/tbody/tr[3]/td[$i]/input\").Click() } #One last checkbox $ChromeDriver.FindElementByXPath('//*[@id=\"gPermissionsTable\"]/tbody/tr[3]/td[15]/input').Click() #Saving all the changes $ChromeDriver.FindElementByXPath('//*[@id=\"space-tools-body\"]/form/div/div[9]/input[1]').Click()   You can see that in a loop I‚Äôm only clicking boxes where cell number is equal $i. I‚Äôve checked that first box which interests me has number 4 and I need to check every box until 13 and then box 15. At the end don‚Äôt forget to Save all changes üòâ   Files   During my automation journey the need to download and upload files was bound to come sooner or later.  Downloading is easy and there is nothing new, just find Download button and click on it!  Uploading a file took me a some time to figure out but it turned out easy too!   #Find upload button and then send path to file $ChromeDriver.FindElementsById('file').SendKeys('C:\\Temp\\14853163_141016446369733_5206568431232995795_o.jpg') #CLicking on image convert button $ChromeDriver.FindElementById('convert-button').Click()   Trick to that was just to send file path to upload element on website.   Summary   I hope that those few use cases will help you in feeling Selenium vibe and you will be able to apply them in your automation tasks!    See you in next! üòâ üß†  ","categories": ["Selenium"],
        "tags": ["Selenium","Powershell","Automation","Credentials","Confluence"],
        "url": "http://localhost:4000/selenium/Selenium-Powershell-Usecases/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Binding macOS device to Active Directory using Intune",
        "excerpt":"Intro   Catchy title, isn‚Äôt it? But be sure that it is possible to bind any macOS device to your local (for now) Active Directory using payload profile uploaded to ‚ö°Intune‚ö°. Those of you who connected Intune to Jamf might not find this post useful. But if you want to some costless solution you may proceed with reading üòâ   macServer   At the moment when some Mac devices started to appear at my company we decided to implement MDM solution. Back then I‚Äôve tested Intune but it did not pass all of the requirements‚Ä¶macServer did provide all of the necessary features and it costs only $19.99!   Once you buy it just install it on management device, configure some stuff and you are ready enroll your devices. Customizing management profiles is piece of cake üç∞. Variety of options is astonishing!      and many more!   So we did binding to AD using macServer. What is required:      Service account in AD which has rights to create, rename computer objects in specified OU   Organizational Unit which will store computer objects   Connectivity to domain controller from Mac device   This is how it looks:      and for administrative rights on device configure this tab:      all set!   But this is not what you came for, right?   Payload profile   Time came to look into Intune capabilities once again. At first glance I was disappointed but then I had an idea üí°! What are those custom profiles? I need to upload some file‚Ä¶ Maybe something like this:      Bingo ü•≥   So it looks like I can do everything what macServer allows just by downloading present configuration applied to end device ü§Ø.   Let‚Äôs put it to the test and create custom profile which will bind device to Active Directory!      This how this xml looks inside. I‚Äôve made changes so that if you want to use it in you organization just copy it and fill the ‚Äògaps‚Äôin keys:      ADDomainAdminGroupList   ADOrganizationalUnit   ADPreferredDCServer   Password   PayloadDisplayName   PayloadIdentifier   UserName   HostName   PayloadOrganization   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt;  &lt;key&gt;PayloadContent&lt;/key&gt;  &lt;array&gt;   &lt;dict&gt;    &lt;key&gt;ADAllowMultiDomainAuth&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADAllowMultiDomainAuthFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADCreateMobileAccountAtLogin&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADCreateMobileAccountAtLoginFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADDefaultUserShell&lt;/key&gt;    &lt;string&gt;/bin/bash&lt;/string&gt;    &lt;key&gt;ADDefaultUserShellFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADDomainAdminGroupList&lt;/key&gt;    &lt;array&gt;     &lt;string&gt;yourdomain.com\\RemoteAccess-macOS&lt;/string&gt;     &lt;string&gt;yourdomain.com\\{`{serialnumber}}-Admins&lt;/string&gt;    &lt;/array&gt;    &lt;key&gt;ADDomainAdminGroupListFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADForceHomeLocal&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADForceHomeLocalFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADMapGGIDAttributeFlag&lt;/key&gt;    &lt;false/&gt;    &lt;key&gt;ADMapGIDAttributeFlag&lt;/key&gt;    &lt;false/&gt;    &lt;key&gt;ADMapUIDAttributeFlag&lt;/key&gt;    &lt;false/&gt;    &lt;key&gt;ADMountStyle&lt;/key&gt;    &lt;string&gt;smb&lt;/string&gt;    &lt;key&gt;ADNamespace&lt;/key&gt;    &lt;string&gt;domain&lt;/string&gt;    &lt;key&gt;ADNamespaceFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADOrganizationalUnit&lt;/key&gt;    &lt;string&gt;OU=Workstations,OU=Computers,DC=yourdomain,DC=com&lt;/string&gt;    &lt;key&gt;ADPacketEncrypt&lt;/key&gt;    &lt;string&gt;allow&lt;/string&gt;    &lt;key&gt;ADPacketEncryptFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADPacketSign&lt;/key&gt;    &lt;string&gt;allow&lt;/string&gt;    &lt;key&gt;ADPacketSignFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADPreferredDCServer&lt;/key&gt;    &lt;string&gt;yourdomain.com&lt;/string&gt;    &lt;key&gt;ADPreferredDCServerFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADRestrictDDNSFlag&lt;/key&gt;    &lt;false/&gt;    &lt;key&gt;ADTrustChangePassIntervalDays&lt;/key&gt;    &lt;integer&gt;14&lt;/integer&gt;    &lt;key&gt;ADTrustChangePassIntervalDaysFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADUseWindowsUNCPath&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADUseWindowsUNCPathFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ADWarnUserBeforeCreatingMA&lt;/key&gt;    &lt;false/&gt;    &lt;key&gt;ADWarnUserBeforeCreatingMAFlag&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;ClientID&lt;/key&gt;    &lt;string&gt;%ComputerName%&lt;/string&gt;    &lt;key&gt;HostName&lt;/key&gt;    &lt;string&gt;yourdomain.com&lt;/string&gt;    &lt;key&gt;Password&lt;/key&gt;    &lt;string&gt;PASSWORD&lt;/string&gt;    &lt;key&gt;PayloadDisplayName&lt;/key&gt;    &lt;string&gt;Directory (yourdomain.com)&lt;/string&gt;    &lt;key&gt;PayloadEnabled&lt;/key&gt;    &lt;true/&gt;    &lt;key&gt;PayloadIdentifier&lt;/key&gt;    &lt;string&gt;com.apple.mdm.yourdomain.com&lt;/string&gt;    &lt;key&gt;PayloadType&lt;/key&gt;    &lt;string&gt;com.apple.DirectoryService.managed&lt;/string&gt;    &lt;key&gt;PayloadUUID&lt;/key&gt;    &lt;string&gt;81d771a0-c8e2-0137-bbba-68fef702cbe7&lt;/string&gt;    &lt;key&gt;PayloadVersion&lt;/key&gt;    &lt;integer&gt;1&lt;/integer&gt;    &lt;key&gt;UserName&lt;/key&gt;    &lt;string&gt;USERNAME&lt;/string&gt;   &lt;/dict&gt;  &lt;/array&gt;  &lt;key&gt;PayloadDisplayName&lt;/key&gt;  &lt;string&gt;Settings for %ComputerName%&lt;/string&gt;  &lt;key&gt;PayloadEnabled&lt;/key&gt;  &lt;true/&gt;  &lt;key&gt;PayloadIdentifier&lt;/key&gt;  &lt;string&gt;com.apple.mdm.yourdomain.com.6b79c2a0-c8e2-0137-bbb9-68fef702cbe7&lt;/string&gt;  &lt;key&gt;PayloadOrganization&lt;/key&gt;  &lt;string&gt;yourdomain.com&lt;/string&gt;  &lt;key&gt;PayloadRemovalDisallowed&lt;/key&gt;  &lt;false/&gt;  &lt;key&gt;PayloadScope&lt;/key&gt;  &lt;string&gt;System&lt;/string&gt;  &lt;key&gt;PayloadType&lt;/key&gt;  &lt;string&gt;Configuration&lt;/string&gt;  &lt;key&gt;PayloadUUID&lt;/key&gt;  &lt;string&gt;6b79c2a0-c8e2-0137-bbb9-68fef702cbe7&lt;/string&gt;  &lt;key&gt;PayloadVersion&lt;/key&gt;  &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/plist&gt;   And as a result I got:            Summary   $19.99 was very well spent money! Thanks to that I can prepare desired configuration on macServer, export it to xml file, upload it to Intune. At this moment I‚Äôve not tested all of the options and how will they apply but I hope high hopes in this method.   Intune allows you to build dynamic strings in configurations - Configuration Tokens.  I‚Äôve used one in device domain group for administrator privileges  yourdomain.com{`{serialnumber}}-Admins   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","Active Directory","macOS"],
        "url": "http://localhost:4000/intune/Intune-Bind-Device-AD/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Remote change of wallpaper with Powershell",
        "excerpt":"Intro   For me those kind of ideas are the best. While solving such issue I‚Äôm learing mysteries of OS which I would normally even won‚Äôt care about üòã. And playing a trick on someone is my fuel üòà   How to do it   Windows stores information about wallpaper in registry for every user in their profile hives. In ‚ÄúHKU:$UserSID\\Control Panel\\Desktop‚Äù there are three string values which you need to maniuplate:                  Wallpaper       The path to the wallpaper picture can point to a: .bmp, .gif, .jpg, .png, or .tif file                 TileWallpaper       - 0: The wallpaper picture should not be tiled  - 1: The wallpaper picture should be tiled                 WallpaperStyle       - 0:  The image is centered if TileWallpaper=0 or tiled if TileWallpaper=1   - 2:  The image is stretched to fill the screen   - 6:  The image is resized to fit the screen while maintaining the aspect ratio. (Windows 7 and later)   - 10: The image is resized and cropped to fill the screen while maintaining the aspect ratio. (Windows 7 and later)           That‚Äôs all the magic.   By default when your are remoting to another device session connects you to profile linked with credentials you used. So to change wallpaper for another user you need to look for SID of his profile. It can be simply done like that:   Set-Location 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList' $profiles = Get-ChildItem | Where-Object {$PSItem.PSPath -like 'S-1-5-21*'} $UserName = $profiles | Get-ItemProperty | Select-Object ProfileImagePath,PSChildName   User profiles start with S-1-5-21 so I‚Äôm searching only for those. ProfileImagePath stores location of profile folder which contains username and PSChildName stores SID which is needed for locating registry profile hive. With those information you can already go to setting registry values or if you want to change wallpaper for currently logon user use:   $Sessions = quser $LogonUsers = $Sessions -replace  '\\s{2,}', ',' | ConvertFrom-Csv Write-Host 'Logon users (active user has '&gt;'):' -ForegroundColor Yellow $i=0 Foreach($User in $LogonUsers.USERNAME){     Write-Host \"$i. $User\"     $i++ } Write-host 'Choose user for which you want to set wallpaper (0,1,2,etc):' -NoNewline $Choice = Read-Host  $ActiveUsers =  $LogonUsers[$Choice] $UserSID = ($UserName | Where-Object {$PSItem.ProfileImagePath -like \"*$($ActiveUsers.USERNAME.Replace('&gt;',''))\"}).PSChildName   If you choose your victim you can proceed with applying your wallpaper.   $Scriptblock = {     param($UserSID)     $ProfileHive = \"HKU:\\$UserSID\\Control Panel\\Desktop\"     Write-Host 'Wallpaper file present: ' -NoNewline     $NewWallpaperPath = c:\\path\\to\\your\\file.jpg     $TestPath = Test-Path -Path $NewWallpaperPath      if ($TestPath -eq 'True') {         Write-Host $TestPath -ForegroundColor Green     }     else {         Write-Host $TestPath -ForegroundColor Red         Break     }     Write-Host 'Connecting HKEY_USERS'     New-PSDrive -PSProvider Registry -Name HKU -Root HKEY_USERS | out-null     Set-location HKU:     Write-Host 'Old wallpaper file' -ForegroundColor Red     Get-ItemProperty -Path $ProfileHive | Select-Object WallPaper -ExpandProperty $Value | Out-Default     Write-Host 'Changing wallpaper' -ForegroundColor Yellow     Write-Host     Remove-ItemProperty -path $ProfileHive -name WallPaper      set-itemproperty -path $ProfileHive -name WallPaper -value $NewWallpaperPath     set-itemproperty -path $ProfileHive -name WallPaperStyle -value 2     #Set-ItemProperty -Path $ProfileHive -Name TileWallpaper -value 0     Write-Host 'New wallpaper file' -ForegroundColor Green     Get-ItemProperty -Path $ProfileHive | Select-Object WallPaper -ExpandProperty $Value | Out-Default     1..3 | ForEach-Object { RUNDLL32.EXE USER32.DLL, UpdatePerUserSystemParameters } }  Invoke-Command -ComputerName $ComputerName -Scriptblock $Scriptblock -ArgumentList $UserSID  There is not much happening this code but I think that last line of scriptblock might be misterious. By default new setting are applied on user logon but to speed up changes you can run   RUNDLL32.EXE USER32.DLL, UpdatePerUserSystemParameters   But from my experience and from what I‚Äôve read online it is the best to run it a few times just to be sure!   Summary   Prank like that is harmless but be sure that you are not messing with someone who might fight back with even bigger guns üíÄ.   See you in next! üòâ üß†  ","categories": ["Powershell"],
        "tags": ["Tips'n'Tricks","Workstations"],
        "url": "http://localhost:4000/powershell/Change-Wallpaper-Remotely/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Intune - dealing with ErrorCode 0x8018002b",
        "excerpt":"Intro   Happy New Year!ü•≥ Starting 2020 I promised myself to increase frequency of the posts so fingers crossed that it works outüòâ   In this post you will find couple of steps that are worth to try if your device is having problems enrolling to Intune. I can‚Äôt guaranty that it will help with every device. That‚Äôs why you should think of this post as check list of things to keep in mind while debugging workstation.   My environment configuration:      Hybrid Azure AD Join   Auto-enrollment to Intune with GPO   Things that will come in handy during troubleshooting:      dsregcmd /status - cmdlet which shows is device is AAD joined. More details   Event Viewer - Application and Services Logs:            Microsoft/Windows/AAD       Microsoft/Windows/DeviceManagement-Enterprise-Diagnostics-Provider       Microsoft/Windows/User Device Registration           Systeminfo   BIOS update   Check if your device has up-to date BIOS version. Sometimes simple plain update will get things moving. If you are using Dell laptops it is best to use Dell Command | Update tool. Version 3.1.0 brought a lot of nice improvements and features! I like using it from Powershell terminal and it is very simple:   #Go to location of installation cd 'C:\\Program Files (x86)\\Dell\\CommandUpdate' #Firstly you need to set bios password if you have one .\\dcu-cli.exe /configure -biospassword=\"YourBiosPass\" #Response should be '-biospassword' setting updated with value 'YourBiosPass'. Execution completed. Program exited with return code: 0 #Updating BIOS .\\dcu-cli.exe /applyupdates -autoSuspendBitLocker #Tool will scan device for any drivers that need update. For BIOS update laptop needs to connected to power source and -autoSuspendBitLocker is needed too.   after reboot update will be applied.   Boot mode   Some devices might have been configured so long time age that its partition style is MBR and it still runs in Legacy mode with Secure boot Off. It can be changed without reinstalling OS! Conversion to GPT feels like a huge risk so if you have a way to backup whole disk I recommend that. But I‚Äôve done it on two different laptops in: FullOS Mode and in Windows 10 Safe Mode with Command-prompt and it worked both times! More details about the tool here. Keep in mind that changes cannot be undone and device will only boot in UEFI mode. So if you are doing it remotely you will need Dell Command | PowerShell Provider to make changes in BIOS from Windows.   #It is good to run validate parameter first c:\\Windows\\System32&gt;.\\mbr2gpt /validate MBR2GPT: Attempting to validate disk 0 MBR2GPT: Retrieving layout of disk MBR2GPT: Validating layout, disk sector size is: 512 MBR2GPT: Validation completed successfully #If you are doing this from Widnows use /allowFullOS c:\\Windows\\System32&gt;.\\mbr2gpt /convert /allowFullOS  MBR2GPT will now attempt to convert disk 0. If conversion is successful the disk can only be booted in GPT mode. These changes cannot be undone!  MBR2GPT: Attempting to convert disk 0 MBR2GPT: Retrieving layout of disk MBR2GPT: Validating layout, disk sector size is: 512 bytes MBR2GPT: Trying to shrink the system partition MBR2GPT: Trying to shrink the OS partition MBR2GPT: Creating the EFI system partition MBR2GPT: Installing the new boot files MBR2GPT: Performing the layout conversion MBR2GPT: Migrating default boot entry MBR2GPT: Adding recovery boot entry MBR2GPT: Fixing drive letter mapping MBR2GPT: Conversion completed successfully MBR2GPT: Before the new system can boot properly you need to switch the firmware to boot to UEFI mode!    Now with the help of another awesome Dell tool I will be changing boot mode   Install-Module -Name DellBIOSProvider #Check what options are available and how does BIOS objects look like Get-Item DellSmbios:\\BootSequence\\BootList | select *  PSPath                    : DellBIOSProvider\\DellSmbiosProv::DellSmbios:\\BootSequence\\BootList PSParentPath              : DellBIOSProvider\\DellSmbiosProv::DellSmbios:\\BootSequence PSChildName               : BootList PSDrive                   : DellSmbios PSProvider                : DellBIOSProvider\\DellSmbiosProv PSIsContainer             : False Attribute                 : BootList CurrentValue              : UEFI BOOT ShortDescription          : Boot List Option PossibleValues            : {Legacy, Uefi} UnsupportedPossibleValues : {} Description               : Boot List option determines the boot mode of the system. Uefi - Enables booting to Unified                             Extensible Firmware Interface (UEFI) capable operating systems. Legacy (the default) - Ensu                             res compatibility with OSes that do not support UEFI. NOTE: Legacy boot mode is not allowed                              when secure boot is enabled or Legacy Option ROM is disabled. #Setting boot mode to UEFI Set-Item DellSmbios:\\BootSequence\\BootList -Value Uefi #Checking setting of Secureboot Get-Item DellSmbios:\\SecureBoot\\SecureBoot | select *                                             PSPath                    : DellBIOSProvider\\DellSmbiosProv::DellSmbios:\\SecureBoot\\SecureBoot PSParentPath              : DellBIOSProvider\\DellSmbiosProv::DellSmbios:\\SecureBoot PSChildName               : SecureBoot PSDrive                   : DellSmbios PSProvider                : DellBIOSProvider\\DellSmbiosProv PSIsContainer             : False Attribute                 : SecureBoot CurrentValue              : Enabled ShortDescription          : Secure Boot Enable PossibleValues            : {Enabled, Disabled} UnsupportedPossibleValues : {} Description               : Enables or disables the secure boot feature. For secure boot to be enabled, the system need                             s to be in UEFI boot mode and the Enable Legacy Option ROMs option needs to be turned off.                             CAUTION: Using the Dell Command | PowerShell Provider, you cannot disable this feature. NOT                             E: One of the methods of configuring this feature is from the BIOS setup screen. #Turn on SecureBoot Set-Item DellSmbios:\\SecureBoot\\SecureBoot -Value Enabled   Now it is safe to reboot!   Clear TPM   All above steps are necessary for OS to correctly communicate with Trusted Platform Module chip. If those steps do still did not do a thing just try to clear microcontroller. It can be easily done from Windows or in BIOS. üî•üî•Before proceeding remember to backup your Bitlocker key to safe locationüî•üî•  also I recommend suspending Bitlocker because it will allow to automatically save recovery key in TPM again after wiping chip.   #Run powershell as local admin Suspend-BitLocker -MountPoint C #provide OS disk letter Clear-Tpm #And you are done   Work and school account   We‚Äôve gone so far and if device did not join AzureAD at this point we need to give it one last kick-start! If on your device there are Office 365 family apps installed open one of them (it really should not matter but I prefer Word) and go to Account Settings and then click sign out.         If previous steps did their magic when you sign-in you should see window:      Click Yes and you device should now join AzureAD and after couple of minutes and reboot Intune too. If you bump into error message which says Your device is already managed by an organization and you are sure that there are no Work or School accounts added in settings your last resort might be to reinstall Windows üò´. It happened to me once and I found no other resolution‚Ä¶   Summary   In modern desktop management I think that it all comes down to health of device TPM and Windows ability to communicate with chip.   I hope that you will find those steps useful. Some cases might work after applying one of the remediation‚Äôs and others will need to be diagnosed and fixed thoroughly. Unless there are some hardware issues with device I think that all the issues can be fixed üòâ   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","ActiveDirectory","Workstations","Windows 10"],
        "url": "http://localhost:4000/intune/Intune-Problems-Solving/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "The power of Three! Intune + Powershell + MicrosoftGraph",
        "excerpt":"Intro   Today I‚Äôd like to show you how I‚Äôve was able to force reboot 197 devices to fix Windows Updates issue with just a few lines of code       The issue   Some users don‚Äôt have a habit to restart device from time to time‚Ä¶ In our environment that behavior led to problem with installing Quality updates on endpoints. December 2019 Feature update requires one reboot after downloading to start installing. Without that one reboot Quality updates just stacked and it all lead to major security risks! Yes, Intune allows you to set Deadline for updates but it is connected with applying update process.      To check how big this issue could be you can go to Windows 10 update rings and then select desired update ring. Your eyes probably see something like:      ‚ùó‚ùó Look carefully because this view only shows update profile assignment status ‚ùó‚ùó not real status of updates per device. To see that you need to click on End user update statusüïµüèº      There you can see detailed status for each device. And the options are:                   Status       Value       Description                 upToDate       0       There are no pending updates, no pending reboot updates and no failed updates.                 pendingInstallation       1       There are updates that‚Äôs pending installation which includes updates that are not approved. There are no Pending reboot updates, no failed updates.                 pendingReboot       2       There are updates that requires reboot. There are not failed updates.                 failed       3       There are updates failed to install on the device.           Time to fix it! üî±   Solution for described scenario is plain simple reboot which should allow Windows Update service to push installation forward. You can nicely ask user to perform reboot but it might have effectiveness around a few or a dozen percentage. To fix it immediately you will need:      PowerShell SDK for Microsoft Intune Graph API   Account with Global Administrator Rights or proper configuration of Powershell MSGraph in your tenant   Powershell console   After you install Microsoft Graph module you need to connect to service and from there you will be able to grab list of devices with their update statuses and perform reboot. I recommend to get familiar with documentation here and Graph Explorer here it will come in handy in your journey with MicrosoftGraph üåå.   Time to make some mess!    #Connecting to GraphAPI Connect-MSGraph  #Get list of Windows devices $MSGraphComputers = (Get-DeviceManagement_ManagedDevices).value | Where { $PSItem.operatingSystem -eq 'Windows'}  #Get list of Windows10 Update rings $WindowsUpdateRings = Get-DeviceManagement_DeviceConfigurations | Where { $PSItem.'@odata.type' -like '*windowsupdate*' }  | ogv -PassThru  #Get list of update states $DeviceUpdateStates = foreach($Ring in $WindowsUpdateRings){     (Invoke-MSGraphRequest -HttpMethod GET -Url \"https://graph.microsoft.com/beta/deviceManagement/deviceConfigurations/$($Ring.id)/microsoft.graph.windowsUpdateForBusinessConfiguration/deviceUpdateStates\").Value }  #Force reboot devices $DeviceUpdateStates | Where { $PSItem.'Update Status' -eq 'Failed' } | Invoke-DeviceManagement_ManagedDevices_RebootNow    Device will be restarted within 10 minutes with first notification:      and 2 minutes before:      Yeah it is in language set in Windows   Summary   Even though Intune itself does not allow to perform bulk actions it can be easily done with a little bit of Powershell magic‚ú®   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","Powershell","Microsoft Graph"],
        "url": "http://localhost:4000/intune/Intune-BulkActions/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "How long would it take...",
        "excerpt":"Intro   Multi-factor authentication (MFA) is great security measure. The most common second factor is probably SMS code sent to your mobile phone. And what could go wrong there? Well I don‚Äôt know how but at some point recently we had around 150 users which did not receive codes even though they configured MFA.   Issue   A user raised an issue that he does not receive codes for MFA. Is it cellphone carrier issue? Maybe user changed number and forgot about it? Or something else? First two assumptions were ruled out immediately so I focused on configuration of the service itself. For that I went to user profile in Azure AD and then to Authentication methods. There I saw:      Duplicated international call prefix üòÆ. I‚Äôve removed additional digits - 0048 - and SMS codes began to arrive to user. That was easy! But then wondering came‚Ä¶ how many users might have the same issue? ü§î  To check that I‚Äôve run:   Connect-MsolService $MSONUSER = Get-MsolUser -All | select DisplayName -ExpandProperty StrongAuthenticationUserDetails |` select DisplayName,email,phonenumber   Some sorting and filtering and I ended up with list of around 150 users which fitted in similar pattern where country prefix was doubled. I won‚Äôt fix it manually!! Let‚Äôs use some Powershell of MSGraph üòé.   NOPE   Powershell can‚Äôt do that and API is (as on 25.02.2020) to be hopefully exposed in Q1 2020.  Some quick calculations‚Ä¶      150 users x 2-5 minutes = 300-750 minutes = 5-12, 5 hours      There must be some way!! Wait a minute‚Ä¶ üí°   Selenium   If I‚Äôm not gonna click it then let‚Äôs make browser click for me üòÅ (Checkout my post about starting with Selenium). All I need is list of problematic users with their correct numbers and overview of properties of boxes in authorization methods tab. So to let‚Äôs take a look at url of page while being in MFA tab   https://portal.azure.com/#blade/Microsoft_AAD_IAM/UserDetailsMenuBlade/UserAuthMethods/userId/ 7af69645-0661-451f-b9fd-4fa36946f164/adminUnitObjectId/   The only thing that changes is userID which you can grab from AzureAD like that   Connect-AzureAD $AADUsers = Get-AzureADUser -All:$True #That way we get list of all users and it should look like that: ObjectId                             DisplayName       UserPrincipalName                      UserType --------                             -----------       -----------------                      -------- 7af69645-0661-451f-b9fd-4fa36946f164 Adele Vance       AdeleV@dunesbox.onmicrosoft.com        Member   Next thing. I did not expect that providing box properties will be such challenge. Normally you can operate on ID of an item and it will not change. But portal.azure.com proved me wrong! There IDs are randomly generated on every page refresh üòê. But name of a box always starts with __azc-textBox and at the end there is a digit. At the begging I though that Phone box will always have index 0 but this too was incorrect. There is one more box which is every time while you are on this site‚Ä¶ top search box!      Knowing that I decided not to rely on name of a box entirely but rather on coordinates. So I iterate through first 5   $Boxes = foreach ($i in 0..4) {         $TextBox = \"__azc-textBox$i\"         try {             $LocationX = $ChromeDriver.FindElementByName(\"__azc-textBox$i\").Location.X             $LocationY = $ChromeDriver.FindElementByName(\"__azc-textBox$i\").Location.Y         }         catch {             $TextBox = 'No such box'             $LocationX = $null             $LocationY = $null         }         [pscustomobject] @{             ID        = $TextBox             LocationX = $LocationX             LocationY = $LocationY         }     }   I got results like below and one last thing to do was to identify Phone box.   ID             LocationX LocationY --             --------- --------- __azc-textBox0       283         7 __azc-textBox1       844       295 __azc-textBox2       844       334 __azc-textBox3       844       373 __azc-textBox4       844       412  $MobileBox = $Boxes |` Where-Object {      $PSItem.Locationy -eq (($Boxes |`        Where-Object {            $PSItem.locationx -eq $( ($boxes.locationx | Measure-Object -Maximum).Maximum)         }).locationy | Measure-Object -Minimum).Minimum      }   With all that knowledge I was able to write my script which will modify phone numbers for provided users.    $UsersToFix = import-csv UsersToFix.csv $PathToBin = 'c:\\your\\path\\to\\WebDriver.dll' [System.Reflection.Assembly]::LoadFrom(\"{0}\" -f $PathToBin) if ($env:Path -notcontains \";$PathToBin`Bin\" ) {     $env:Path += \";$PathToBin`Bin\" }  $ChOptions = New-Object OpenQA.Selenium.Chrome.ChromeOptions $ChOptions.AcceptInsecureCertificates = $True $ChromeDriver = New-Object OpenQA.Selenium.Chrome.ChromeDriver($ChOptions) $ChromeDriver.Manage().Window.Maximize() Start-Sleep 2 $ChromeDriver.url = 'https://portal.azure.com/' Start-Sleep 5 $ChromeDriver.FindElementById('i0116').SendKeys($UserName) $ChromeDriver.FindElementById('idSIButton9').Click() Start-Sleep 2 $ChromeDriver.FindElementById('i0118').SendKeys($Password) $ChromeDriver.FindElementById('idSIButton9').Click() #Waiting for 2FA accept.  Start-Sleep 3 $ChromeDriver.FindElementById('idSIButton9').Click()  $SaveButtonXPath = '/html/body/div[1]/div[5]/main/div[4]/div[2]/section/div/div[2]/div[1]/div/ul/li[1]' foreach ($userID in $UsersToFix) {     Write-Default -Info -Message \"Changing user $($userID.UserPrincipalName)\"     $AzureUrl = \"https://portal.azure.com/#blade/Microsoft_AAD_IAM/UserDetailsMenuBlade/UserAuthMethods/userId/$($userID.ObjectId)/adminUnitObjectId/\"     $ChromeDriver.url = $AzureUrl     $ChromeDriver.Navigate().Refresh()     Start-Sleep 5     Write-Output \"Clearing field value\"     $Boxes = foreach ($i in 0..4) {         $TextBox = \"__azc-textBox$i\"         try {             $LocationX = $ChromeDriver.FindElementByName(\"__azc-textBox$i\").Location.X             $LocationY = $ChromeDriver.FindElementByName(\"__azc-textBox$i\").Location.Y         }         catch {             $TextBox = 'No such box'             $LocationX = $null             $LocationY = $null         }         [pscustomobject] @{             ID        = $TextBox             LocationX = $LocationX             LocationY = $LocationY         }     }     $Boxes     $MobileBox = $Boxes |`         Where-Object {          $PSItem.Locationy -eq (($Boxes |`                     Where-Object {                     $PSItem.locationx -eq $( ($boxes.locationx | Measure-Object -Maximum).Maximum)                 }).locationy | Measure-Object -Minimum).Minimum              }      $ChromeDriver.FindElementByName($MobileBox.ID).Clear()     Start-Sleep 1     Write-Output \"Setting user correct number\"          $ChromeDriver.FindElementsByName($MobileBox.ID).SendKeys($UserCorrectNumber)     Start-Sleep 1     Write-Output \"Saving changes\"         $ChromeDriver.FindElementByXPath($SaveButtonXPath).Click()     Start-Sleep 1 }   Summary   Thanks to that fixing this issue took around one hour where 25 minutes was runtime of this script. It is not the most efficient way but for now it is the only one so I hope it will be useful for you!   See you in next! üòâ üß†  ","categories": ["Selenium"],
        "tags": ["2FA","Azure","Active Directory","Powershell","Selenium"],
        "url": "http://localhost:4000/selenium/MFA-Selenium/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Harness Intune Win32 app installer",
        "excerpt":"Intro   Whole world gone mad but keeping your endpoints patched should not wait. Case for this post is to fix vulnerability COVID-19 ü¶† on devices üò∑‚Ä¶ wait what?? I meant INTEL-SA-00189! Using Intune for this task is now the best choice under circumstances when 100% of employees work remote from homes. So let‚Äôs do it!   Prepare your script   To use Intune Win32 application deployment you need to wrap installer with special tool (more info below), provide install and uninstall command and you are kind of done. For some basic stuff or in-house apps it should be enough but when you want some more control over what is happening during deployment I will let you in on a little secret‚Ä¶ you can wrap Powershell scriptü•Ç. Well that‚Äôs neat! Thanks to that I was able to check if workstation has my favorite folder for storing stuff and determine exit code based on installation result.   #Check for path where logs will be stored if (!(Test-Path C:\\Temp)) {     New-Item -Path C:\\ -ItemType Directory -Name Temp     New-Item -Path C:\\Temp -ItemType Directory -Name SU } elseif (!(Test-Path C:\\Temp\\SU)) {     New-Item -Path C:\\Temp -ItemType Directory -Name SU }  function Get-Info {     \"[$Env:ComputerName] [$Tag] [$((Get-Date -Format 'yyyy-MM-dd HH:mm:ss').ToString())] [$($env:UserName)] [$($MyInvocation.ScriptLineNumber)]\" }  function Exit-WithCode {     param     (         $exitcode     )      $host.SetShouldExit($exitcode)     exit }  $SoftwareName = 'IntelGraphics' #Check currently installed version of driver $InstallationVersion = Get-CimInstance -ClassName win32_pnpsigneddriver | Select-Object devicename, manufacturer, driverversion | Where-Object {$PSItem.DeviceName -like 'Intel(R)*HD Graphics*'} #Write driver version to file \"$(Get-Info) Installed version $($InstallationVersion.driverversion)\" | Out-File -Append -FilePath c:\\Temp\\SU\\IntelGraph.log #Install drivers silently $Process = start-process \".\\Intel\\igxpin.exe\" -ArgumentList @('-report c:\\temp\\su\\IntelGraph.log', '-s') -NoNewWindow -Wait -PassThru $Process.WaitForExit() #Determine exit of installation based on exitcode of Intel   If($Process.Exitcode -eq '0'){     #Hard reboot     Exit-WithCode -exitcode 1641 }else{     #Retry     Exit-WithCode -exitcode 1618 }   There is not much going but it shows how simple it can be to fit installation to your needs. Notice that Intel installer path is .\\Intel\\igxpin.exe it means that Microsoft Intune Management Extension runs installation with current path set to inside of deployed package.      Another thing is that after installation is complete I‚Äôm exiting the script with specific codes. These are default codes with assigned action. I will explain them later.üòâ   Microsoft Intune Content Prep Tool   Before you will be able create app deploy in Intune you need to wrap your stuff into .intunewin format. Go here to get wrapping tool üéÅ. Using it is child‚Äôs play:      Prepared package upload to app profile      Installation command and return codes   Going further, you will need to specify command for installing your package. Because it is powershell script remember to run it with execution policy bypass parameter.      To find out software uninstall command run code below on device which already has it installed   Get-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',                     'HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',                     'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*',                     'HKCU:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*' -ErrorAction Ignore | Where-Object DisplayName | Select-Object -Property DisplayName, DisplayVersion, UninstallString, InstallDate | Sort-Object -Property DisplayName   It scans through registry and will list all applications on device.  Installing Intel Graphics drivers requires device reboot. It can be done with installation parameter but it will do the reboot immediately which in business is not a good option. Better way is to act accordingly to return codes.    Soft reboot      will only show Toast notification that your device needs to be restarted after installing distributed software. In your OS language.      But only if you allow it      Hard reboot      will too show Toast notification about restart but also force user to reboot the device. And setting Restart grace period is good practice.         And in summary you will see      Detection rule   Last step of app deployment is verification if software is present on device. You can specify this setting is many different ways:      More detailed info you will find here. In this deployment I decided to use Custom detection script   $Driver = Get-CimInstance -ClassName win32_pnpsigneddriver | Select-Object devicename, manufacturer, driverversion | Where-Object {$PSItem.DeviceName -like 'Intel(R)*HD Graphics*'}  if ($Driver.driverversion -eq '26.20.100.6888') {     Write-Output 'Newest version installed'     #Exit code will be 0 and STDOUT not empty } else {     exit 1 }    And this table explains how it works                  Exit code       Data read from Write-Output       Detection state                 0       Empty       Not detected                 0       Not empty       Detected                 Not zero       Empty       Not detected                 Not zero       Not Empty       Not detected           Summary   Deployment of apps using Win32 allows you to do a lot of magic with great precise! For sure I will play with it a lot.üßô‚Äç‚ôÇÔ∏è  Sneak peak on deployment status:      See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","Workstations","Powershell"],
        "url": "http://localhost:4000/intune/Intune-Win32-CustomScript/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Deploy Chromium-Edge PWAs as Start menu tiles",
        "excerpt":"Intro   Yesterday colleague of mine sent me interesting video - How to open ‚Äúmultiple instances‚Äù of Microsoft Teams. Which got me thinking, is there a way to customize those apps and attach them for employees to have quick access links on their workstations?? Drum roll‚Ä¶ü•Å   Deploy new Edge   This whole solution is based on the newest Chromium-Edge so first thing you should do is to migrate your users to it. With the help of Intune it‚Äôs a piece of cake üòä. Go to apps and click Add, select Microsoft Edge and proceed with configuration.            Now that it is being deployed we can prepare our Start menu Tiles.   Start menu Tiles   Basically what installing a site as an app in Edge is creation of simple shortcut with some AppID:   ‚ÄúC:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge_proxy.exe‚Äù ‚Äìprofile-directory=‚ÄùDefault‚Äù ‚Äìapp-id=idedlkepfahmdemmnladahgfmcaapdjg   But what you can do is modify this like that:   ‚ÄúC:\\Program Files (x86)\\Microsoft\\Edge Dev\\Application\\msedge_proxy.exe‚Äù ‚Äìprofile-directory=‚ÄùDefault‚Äù ‚Äìapp=https://universecitiz3n.tech/   And you get link to my blog!üòÜ      That‚Äôs one app but how about creating multiple apps using Powershell! For this project I‚Äôve created input data file with:      App Name   Site link   App icon   [   {     \"Application\": \"Blog\",     \"Link\": \"https://universecitiz3n.tech/\",     \"Icon\": \"universe-icon.ico\"   },   {     \"Application\": \"Fun\",     \"Link\": \"https://9gag.com/\",     \"Icon\": \"9gag-icon.ico\"   },   {     \"Application\": \"Teams\",     \"Link\": \"https://teams.microsoft.com/\",     \"Icon\": \"teams-icon.ico\"   }, ]    This input then goes to this script   $Config = Get-Content .\\ConfigJSON.json | ConvertFrom-Json foreach ($item in $Config) {     $SourceFileLocation = \"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge_proxy.exe\"     $Arguments = \"--profile-directory=Default --app=$($item.Link)\"     #This is a location of global start menu on workstation     $ShortcutLocation = \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\$($item.Application).lnk\"     $WScriptShell = New-Object -ComObject WScript.Shell     $Shortcut = $WScriptShell.CreateShortcut($ShortcutLocation)     $Shortcut.TargetPath = $SourceFileLocation     #Location of icons on workstation     $Shortcut.IconLocation = (Get-item \".\\icons\\$($item.icon)\").FullName     $Shortcut.Arguments = $Arguments     $Shortcut.Save()     Write-Output \"Adding $($item.Application) to start menu\" }   And that is how we created Start menu items which work as Edge PWAs!   Start layout deployment   Again thanks to Intune this task couldn‚Äôt be easier!!  Firstly drag and drop all apps to some group and place group in destined location      Secondly export created layout to xml with Powershell   Export-StartLayout -Path c:\\temp\\layout.xml   Resulting XML will contain all tiles so you will need to modify it just to leave our configuration   &lt;LayoutModificationTemplate xmlns:defaultlayout=\"http://schemas.microsoft.com/Start/2014/FullDefaultLayout\" xmlns:start=\"http://schemas.microsoft.com/Start/2014/StartLayout\" Version=\"1\" xmlns=\"http://schemas.microsoft.com/Start/2014/LayoutModification\"&gt;   &lt;LayoutOptions StartTileGroupCellWidth=\"6\" /&gt;   &lt;DefaultLayoutOverride LayoutCustomizationRestrictionType=\"OnlySpecifiedGroups\"&gt;     &lt;StartLayoutCollection&gt;       &lt;defaultlayout:StartLayout GroupCellWidth=\"6\"&gt;         &lt;start:Group Name=\"Important\"&gt;           &lt;start:DesktopApplicationTile Size=\"2x2\" Column=\"4\" Row=\"0\" DesktopApplicationLinkPath=\"%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Maciej Horbacz.lnk\" /&gt;           &lt;start:DesktopApplicationTile Size=\"2x2\" Column=\"0\" Row=\"0\" DesktopApplicationLinkPath=\"%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Fun.lnk\" /&gt;           &lt;start:DesktopApplicationTile Size=\"2x2\" Column=\"2\" Row=\"0\" DesktopApplicationLinkPath=\"%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Teams.lnk\" /&gt;         &lt;/start:Group&gt;       &lt;/defaultlayout:StartLayout&gt;     &lt;/StartLayoutCollection&gt;   &lt;/DefaultLayoutOverride&gt; &lt;/LayoutModificationTemplate&gt;   And to block newly created tiles from editing by user you must specify parameter at line:    &lt;DefaultLayoutOverride LayoutCustomizationRestrictionType=\"OnlySpecifiedGroups\"&gt;   But the rest of the tiles will not be changed.   Such prepared xml can be deployed using Intune. Go to Configuration profiles, create Device restrictions profile, upload xml            And no other settings are required!   Summary   Chromium-Edge PWAs is such great feature! And taking advantage of it is simple a thing! One last thing‚Ä¶ make sure that the icons are somewhere to found the workstation   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","Powershell","Workstations"],
        "url": "http://localhost:4000/intune/Chromium-Edge-PWAs/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Windows Task Scheduler. Automate stuff on chosen computer üßëüèª‚Äçüíª",
        "excerpt":"Intro   As and IT Pro sometimes you might get stuck while trying to run some application on endpoint or you want to execute some command at certain point of time or at desired conditions. Well you guessed‚Ä¶just use built-in Task Scheduler and it will take care of everything üßôüèª.   You can use the Task Scheduler to execute tasks such as starting an application, sending an email message, or showing a message box. Tasks can be scheduled to execute in response to these events, or triggers.      When a specific system event occurs.   At a specific time.   At a specific time on a daily schedule.   At a specific time on a weekly schedule.   At a specific time on a monthly schedule.   At a specific time on a monthly day-of-week schedule.   When the computer enters an idle state.   When the task is registered.   When the system is booted.   When a user logs on.   When a Terminal Server session changes state.   Basic theory   Let‚Äôs talk more about this tasks. A task is the scheduled work that the Task Scheduler service performs. A task is composed of different components, but a task must contain a trigger that the Task Scheduler uses to start the task and an action that describes what work the Task Scheduler will perform.   The following illustration shows the task components.         Triggers: Task Scheduler uses event or time-based triggers to know when to start a task. Every task can specify one or more triggers to start the task.   Actions: These are the actions, the actual work, that is performed by the task. Every task can specify one or more actions to complete its work.   Principals: Principals define the security context in which the task is run. For example, a principal might define a specific user or user group that can run the task.   Settings: These are the settings that the Task Scheduler uses to run the task with respect to conditions that are external to the task itself. For example, these settings can specify the priority of the task with respect to other tasks, whether multiple instances of the task can be run, how the task is handled when the computer is in an idle condition, and other conditions.      Note: By default, a task will be stopped 72 hours after it starts to run. You can change this by changing the ExecutionTimeLimit setting.       Registration Information: This is administrative information that is gathered when the task is registered. For example, this information describes the author of the task, the date when the task was registered, an XML description of the task, and other information.   Data: This is additional documentation about the task that is supplied by the author of the task. For example, this data may contain XML Help that can be used by users when they run the task. source   Creating first task   To create task open Powershell terminal and type in:   $Trigger = New-ScheduledTaskTrigger -Once -At $(Get-date).AddSeconds(30) $Action = New-ScheduledTaskAction -Execute \"notepad.exe\" Register-ScheduledTask -TaskName \"First task - open notepad\" -Trigger $Trigger -Action $Action   It will open notepad after 30 seconds delay. From that point you can start building up your task.   Trigger   As I mentioned earlier task scheduler provides you with wide range of time-based, event-based triggers. For instance, to schedule task to start on Friday at 3 PM once every 3 weeks:   $Trigger = New-ScheduledTaskTrigger -Weekly -WeeksInterval 3 -DaysOfWeek Friday -At 3pm   If you wish to schedule task to start at system boot:   $Trigger = New-ScheduledTaskTrigger -AtStartup   Some tasks you might wish to end running after certain period of time. To do that you need to specify EndBoundary value in a trigger.   $Trigger = New-ScheduledTaskTrigger -Once -At $(Get-date).AddSeconds(30) $AddHour = (Get-Date).AddHours(1).ToString('O') $Trigger.EndBoundary = $AddHour   When you create the trigger with New-ScheduledTaskTrigger, the time you specify is converted and saved as a string in the trigger‚Äôs StartBoundary property. Be sure to convert your EndBoundary timezone üïí.   User   Use a scheduled task user to run a task under the security context of a specified account.   Using scheduled task allows you to execute actions with highest available privileges that is SYSTEM üÉè. Alternatively you can specify service or any local user. In case of users if you want to run task as other then currently logon user you need to provide credentials for that user.   $User = \"SYSTEM\" Register-ScheduledTask -TaskName $TaskName -Trigger $Trigger -User $User -Action $Action -Settings $Settings -Force   To execute as other user you must use -Password parameter.   Action   The New-ScheduledTaskAction cmdlet creates an object that contains the definition of a scheduled task action. A scheduled task action represents a command that a task executes when Task Scheduler runs the task. You can use a task action definition to register a new scheduled task or update an existing task registration.   A task can have a single action or a maximum of 32 actions. When you specify multiple actions, Task Scheduler executes the actions sequentially. The Task Scheduler service controls tasks activation, and it hosts the tasks that it starts.   Creating action which runs Powershell can be implemented as follows:   $Action = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument '-ex bypass -command \"notepad.exe\" -NoNewWindow -NonInteractive'   Settings   Finally, New-ScheduledTaskSettingsSet allows you to tweak your automation so that you can be sure its maximum execution time is limited   $Settings = New-ScheduledTaskSettingsSet -ExecutionTimeLimit (New-TimeSpan -Hours 1)   ‚Ä¶schedule task restart‚Ä¶   -RestartCount 3 -RestartInterval (New-TimeSpan -Minutes 15)   ‚Ä¶or if device is a laptop‚Ä¶   -AllowStartIfOnBatteries   ‚Ä¶and combined with EndBoundary‚Ä¶   -DeleteExpiredTaskAfter (New-TimeSpan -Seconds 5)   ‚Ä¶go on and checkout all available settings to make sure your task is robust üí™üèº!   Use case - Run Dell Command Update   Now that you know your way around Scheduled Tasks lets use it to make some magic ‚ú®.   If you are using Dell laptop you might know this neat soft called Dell Command | Update. It allows you to scan, download and install all model specific drivers for device using GUI or cmd-line. You can Enter-PSSession to device, go to dcu.exe location and run app to check for updates.   But you can also create task on target device and once it‚Äôs there you will just need to start it. Check it out:   $Trigger = New-ScheduledTaskTrigger -Once -At $(Get-Date).AddMinutes(1) $AddHour = (Get-Date).AddHours(1).ToUniversalTime().ToString('%yy-%M-%dT%H:%m:%s.000Z') $Trigger.EndBoundary = $AddHour $User = \"SYSTEM\" $Action = New-ScheduledTaskAction -Execute \"powershell.exe\" -Argument \"Start-Process 'C:\\Program Files (x86)\\Dell\\CommandUpdate\\dcu-cli.exe' -ArgumentList '/applyUpdates -silent -outputLog=`\"C:\\Temp\\DellCommandUpdate.log`\"' -Wait\" $Settings = New-ScheduledTaskSettingsSet -ExecutionTimeLimit \"01:00\" -AllowStartIfOnBatteries $Task = New-ScheduledTask -Action $Actions -Trigger $Trigger -Settings $Settings -Description 'Update process'  Register-ScheduledTask -TaskName \"DCU Update\" -InputObject $Task -User $User -Force      Note: DCU itself allows you to schedule update check and installation settings. So choose best fitted option for your environment üòâ.    Summary   Task Scheduler is a great tool in automating and allows you execute some actions in different way than just Invoke-Command. Because I‚Äôve used Powershell I can save such script as an .ps1 file and upload it to Intune. It will then be deployed to assigned group of devices!   As always, endless possibilities and‚Ä¶ See you in next! üòâ üß†  ","categories": ["Powershell"],
        "tags": ["Intune","Workstations","Windows 10","Powershell"],
        "url": "http://localhost:4000/powershell/ScheduledTask/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Build, Test, Deploy ‚Äì Software Distribution Using Intune",
        "excerpt":"Intro   The time has come to summarize my project! In this post you will find links to resources where you can find project details üòé   Github   The heart (source code) of the project   Intune Application Sandbox   To configure tool on your device Clone this repo and run Add-SandboxShell.ps1.   It will create folder - C:\\SandboxEnvironment where all necessary items will be stored. You will be also prompt to choose which context menu items you wish to apply.      Run test in Sandbox   Pack with IntunewinUtil   Both   Feel free to dig in and use those cool scripts:      Get-WindowsInstalledPrograms.ps1 - It scans device registry and finds uninstallation strings for Software   Install-ProgramScriptTemplate.ps1 - My template script which uses Powershell to install software   Write-FileLog.ps1 - Simple script which helps you create installation log file with necessary info   PWSH24   It was an honor of conducting a session regarding my tool on this years PowerShell &amp; DevOps Global Conference!      The DevOps Collective, in conjunction with the organizers of PSConf Asia and PSConf Day UK, would like to announce a new event‚Ä¶the Global PowerShell &amp; DevOps Conference ‚Äì Online. With the cancellation of major PowerShell-related conferences including the PowerShell + DevOps Global Summit and PSConf Asia, all three organizing groups were looking at doing some sort of mini-events. Instead of three groups working independently of each other on three different virtual events (all of which would have the same audience), we decided to pool our resources and together produce a 24-hour live stream of the best PowerShell &amp; DevOps content that we can find.    Ton of great sessions now can be found on powershell.org YouTube chanel also mine session! üìΩ   Build, Test, Deploy ‚Äì Software Distribution Using Intune   PSConfBook 3   The last spot where I‚Äôve contributed was The PowerShell Conference Book Volume 3! üìö What‚Äôs PSConfBook?      Multiple subject matter experts have teamed up to bring you the ultimate collection of PowerShell topics that are designed to be like a conference in a book. This book not only delivers top-notch content that rivals any book on the market, but all royalties are donated to the OnRamp scholarship program which bootstraps others into the industry.    Go ahead and grab e-book or hard copy.   The journey continues   Wow a lot has happened! I‚Äôve gained ton of new experience in different fields.ü§ì I hope that you and many others will find my project useful and also I‚Äôm waiting for you contributions!   See you in next! üòâ üß†  ","categories": ["Powershell"],
        "tags": ["Intune","Powershell","WindowsSandbox"],
        "url": "http://localhost:4000/powershell/Intune-App-Sandbox/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Where there is great power, there is great responsibility.",
        "excerpt":"Intro   Using service accounts is one way to manage environment beside Azure Service Principals. Having privileged account which password is not changed won‚Äôt pose a great threat (unless the password is 1234 üòµ) but it is attack vector.   Alright let‚Äôs assume that someone guessed password. If this account has e.g. Global Administrator role then you are immediately Fü¶Üed. Otherwise it‚Äôs not great but under control.   Such accounts MUST be secured using top-notch, cutting edge technology. With help comes Azure KeyVault üîê and  Azure AD Privileged Identity Management üëÆüèª‚Äç‚ôÇÔ∏è.   Prerequisites      Azure AD Privileged Identity Management - Using this feature requires an Azure AD Premium P2 license.   Azure KeyVault - Anybody with an Azure subscription   Azure Automation - Anybody with an Azure subscription. First 500 minutes per month are FREE then $0.002/minute   (Optionally but recommended) Azure DevOps Repository - If you‚Äôre a Visual Studio subscriber and you get Azure DevOps as a benefit, use the Microsoft account associated with your subscription. If you don‚Äôt have a Microsoft account, choose Create one.   Privilaged Service Account Management      On the flow chart above PSAM solution ends at the red line, behind it you implement your job that automation account was created for. In my example I‚Äôm checking Azure AD for Bitlocker Recovery Keys and then taking action depend on outcome of validation script.   Let‚Äôs break it down and dive in into step-by-step configuration.   Azure KeyVault   We can start with creating Azure KeyVault. It will store credentials for your Service Account. Go to Azure KeyVault and fill out creation form.      With KeyVault created you can then add entry for your service account.            Note: To implement KeyVault secrets rotation I‚Äôm inviting you to use your favorite search engine and use one of the available implementations online    Azure Automation   Next step is to create Azure Automation Account. Azure Automation allows you to create and run Runbooks that process provided code e.g. Powershell. Go to Azure Automation Account and fill out creation form.      For purposes of PSAM you will need to add 3 Powershell modules to your Azure Automation:      Az.Accounts   Az.KeyVault   AzureADPreview      Key component of Azure Automation is AzureRunAsAccount      Adding this application to resources permissions you will be able to automate many aspects of Azure cloud. We need to be able to Read KeyVault secrets so lets do that. Go back to your KeyVault and proceed to Access Policies blade and click on Add Access Policy.      In next step select secrets permissions      Select your AzureRunAsAccount as principal      And do not forget to click Save!!      To get secret from KeyVault in Powershell runbook you just need to paste   $AzureRunAsConnection = Get-AutomationConnection -Name 'AzureRunAsConnection'  Connect-AzAccount -CertificateThumbprint $AzureRunAsConnection.CertificateThumbprint -ApplicationId $AzureRunAsConnection.ApplicationId -Tenant $AzureRunAsConnection.TenantId -ServicePrincipal  $secret = Get-AzKeyVaultSecret -VaultName 'KV-PSAM' -Name 'sa-NameResambleItsJob'  $secret  #The same goes for connecting to AzureAD #Connect-AzureAD -TenantID $AzureRunAsConnection.TenantId -ApplicationId  $AzureRunAsConnection.ApplicationId -CertificateThumbprint $AzureRunAsConnection.CertificateThumbprint    And you should be able to see results like      Azure DevOps repository   Now that you‚Äôve got automation to run your scripts, create repository for them üß±. Go to Azure DevOps and create a new project if you don‚Äôt have one.      Initialize a new repo      Then create a new folder and file within      Go back to your Automation Account and procced to Source Control blade and click Add         Click authenticate to connect to DevOps      Fill out the rest of the form         Note: Remember to set Publish runbook to Yes. Otherwise you will have to publish after every sync manually.       This is how sync should look like      Azure AD Privileged Identity Management   Finally you can assign desired role to service account. Go to Privileged Identity Management | Azure AD roles and select a role.   Click Add assignments      Select your service account      Proceed with Assign      One last thing you will need from that blade is roleID. The fastest way is to copy it from address bar      Final   If you are reading this it means that you‚Äôve gone through preparation steps of PSAM! ü•≥ Now it‚Äôs time for the frosting of our cupcake üßÅ.   To read secret and request role using PIM you need to run:   $AzureRunAsConnection = Get-AutomationConnection -Name 'AzureRunAsConnection'  Connect-AzAccount -CertificateThumbprint $AzureRunAsConnection.CertificateThumbprint -ApplicationId $AzureRunAsConnection.ApplicationId -Tenant $AzureRunAsConnection.TenantId -ServicePrincipal  $secret = Get-AzKeyVaultSecret -VaultName 'KV-PSAM' -Name 'sa-NameResambleItsJob'  $Password = $secret.SecretValue 'Cooking service account credentials' $saCredentials = New-Object System.Management.Automation.PSCredential -ArgumentList ('sa-NameResambleItsJob@XXXXXX.onmicrosoft.com', $Password)  'Disconnecting from Az' Disconnect-AzAccount  Import-Module AzureADPreview  \"Connecting to AzureAD\" Connect-AzureAD -Credential $saCredentials | out-null  'Creating PIM schedule' $roles = Get-AzureADMSPrivilegedRoleDefinition -ProviderId aadRoles -ResourceId $AzureRunAsConnection.TenantId $schedule = New-Object Microsoft.Open.MSGraph.Model.AzureADMSPrivilegedSchedule $schedule.Type = \"Once\" $schedule.StartDateTime = (Get-Date).ToUniversalTime().ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\") $schedule.endDateTime = (Get-Date).AddMinutes(30).ToUniversalTime().ToString(\"yyyy-MM-ddTHH:mm:ss.fffZ\")       \"Requesting permissions\" Open-AzureADMSPrivilegedRoleAssignmentRequest -ProviderId 'aadRoles' -ResourceId $AzureRunAsConnection.TenantId -RoleDefinitionId '7698a772-787b-4ac8-901f-60d6b08affd2' -SubjectId '25fca288-42e8-4ef3-8546-4305d7ba197c' -Type 'UserAdd' -AssignmentState 'Active' -schedule $schedule -reason \"Powershell test\"    That‚Äôs nicely formatted output from Runbook      Summary   Having so heavily protected service account with those few tools gives you great advantage against attackers üë®‚Äçüíª. To make this solution better you can make Automation Account variables for roleID or configure PIM to send mail notification to desired distribution list with information that role has been assigned üì©   See you in next! üòâ üß†  ","categories": ["Powershell"],
        "tags": ["Intune","Azure","Encryption","Runbook","Credentials","Automation"],
        "url": "http://localhost:4000/powershell/PSAM/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "I've published my first module with GitHub Actions",
        "excerpt":"Intro   A few days ago an idea was born in my head üí° How can I make Intune-App-Sandbox more available to everyone? It‚Äôs PowerShell so the most suitable form is PowerShell module üì¶.   Prepare your module   It‚Äôs my first 100%, build from scratch module so I had to start with the basics such as module components and types :      A module is made up of four basic components:          Some sort of code file - usually either a PowerShell script or a managed cmdlet assembly.     Anything else that the above code file may need, such as additional assemblies, help files, or scripts.     A manifest file that describes the above files, as well as stores metadata such as author and versioning information.     A directory that contains all of the above content, and is located where PowerShell can reasonably find it.    Note that none of these components, by themselves, are actually necessary. For example, a module can technically be only a script stored in a .psm1 file. You can also have a module that is nothing but a manifest file, which is used mainly for organizational purposes. You can also write a script that dynamically creates a module, and as such doesn‚Äôt actually need a directory to store anything in. The following sections describe the types of modules you can get by mixing and matching the different possible parts of a module together.      After reading this I knew what had to be done.      Create functions for Add-SandboxShell and Update-SandboxShell and place them in folder called Public.   Other scripts and files which are true heart üíñ of Intune-App-Sandbox I‚Äôve placed in Configuration and Helpers folders.   Create module manifest with:   $Description = 'This tool is for testing Powershell Script which is packed using Win32 Content Prep Tool for installing software using Win32 Deployment profile in Intune.'  New-ModuleManifest -Path .\\Intune-App-Sandbox.psd1 -ModuleVersion '1.2' -Author 'Maciej Horbacz' -Description $Description      Create PowerShell module file which exports functions   $Public = @(Get-ChildItem -Recurse -Path $PSScriptRoot\\Public\\*.ps1 | Where-Object { $_ -notmatch '\\.Examples.ps1' })  foreach ($import in $Public) {  try {   . $import.fullname  } catch {   Write-Error -Message \"Failed to import function $($import.fullname): $_\"  } }  Export-ModuleMember -Function $Public.Basename   Test your module   Before uploading anything into public domain be sure to test it somehow locally (yes, it‚Äôs to me from the past).   Thankfully you can do that with PowerShell modules. Create folder somewhere on your drive e.g. C:\\LocalRepo, this will be the path to your local repository. Then you need to register it like that:   Register-PSRepository -Name LocalRepo -SourceLocation 'C:\\LocalRepo\\' -ScriptSourceLocation 'C:\\LocalRepo\\' -InstallationPolicy Trusted   Now you can publish any module to your local repository!   # Publish to a file share repo - the NuGet API key must be a non-blank string  Publish-Module -Path 'c:\\projects\\MyModule' -Repository LocalRepo -NuGetApiKey 'AnyStringWillDo'   Get PSGallery secret   Create or sign in to your account on PowerShell Gallery and go to API Keys   Copy generated key and safely store it in your repository secrets         Create workflow   Github actions workflows are stored at repo location .github/workflows in YAML file.   The easiest way to start building your workflows is to creating one from Actions tab      Before publishing check if your code is holding up to the all good practices out there.   To be sure my first workflow tests my code with PSScript Analyzer and Pester with every commit to master branch   name: Test PowerShell on Windows on: push  jobs:   tests:     name: Pester test and ScriptAnalyzer     runs-on: windows-latest     steps:     - name: Check out repository code       uses: actions/checkout@v2     - name: Perform a Pester test from the Tests.ps1 file       shell: pwsh       run: |         Invoke-Pester .\\tests\\Unit.Tests.ps1 -Passthru          - name: Install PSScriptAnalyzer module       if: success()       shell: pwsh       run: |             Set-PSRepository PSGallery -InstallationPolicy Trusted             Install-Module PSScriptAnalyzer -ErrorAction Stop     - name: Lint with PSScriptAnalyzer       if: success()       shell: pwsh       run: |             Invoke-ScriptAnalyzer -Path .\\Intune-App-Sandbox\\Public\\*.ps1 -Recurse -Outvariable issues -ExcludeRule PSAvoidUsingWriteHost,PSUseShouldProcessForStateChangingFunctions             $errors   = $issues.Where({$_.Severity -eq 'Error'})             $warnings = $issues.Where({$_.Severity -eq 'Warning'})             if ($errors) {                 Write-Error \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\" -ErrorAction Stop             } else {                 Write-Output \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\"             }      After you make sure that it passed the tests you can publish it!   This is where my second workflow comes in   name: Publish PowerShell Module  on:   release:     types: [published]  jobs:   publish-to-gallery:     runs-on: windows-latest     steps:     - uses: actions/checkout@v2     - name: Build and publish       env:         NUGET_KEY: $       shell: pwsh       run: |         .\\build\\build.ps1         Publish-Module -Path .\\Intune-App-Sandbox -NuGetApiKey $env:NUGET_KEY -Verbose      Note: build.ps1 script makes sure that NuGet provider is present and PSGallery is trusted repository    This workflow run only when repository is published as release.            That‚Äôs all! ü•≥   Summary   From now on Intune-App-Sandbox is available as PowerShell module!   All you need to do is   Install-Module 'Intune-App-Sandbox'   See you in next! üòâ üß†  ","categories": ["Github Actions"],
        "tags": ["Powershell module","Intune","Github"],
        "url": "http://localhost:4000/github%20actions/GithubActions/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Verify Azure AD Bitlocker Keys with Microsoft Graph",
        "excerpt":"Intro   Device encryption help you protect your data from leak when device was stolen or missing üöì Bitlocker encryption method uses 48 digit sequence code as an recovery key. In case something happens and you don‚Äôt have this recovery key stored somewhere safe (eg. AzureAD), data on disk is lost forever‚Ä¶‚ö∞Ô∏è  Better safe than sorry!   Backup Bitlocker recovery key   You can store recovery key in local Active Directory or Azure Active Directory. Sending key to AD requires line of sight with domain controller where for AAD Internet connection is enough. Let‚Äôs stick with AAD üí™   To perform backup you will need open PowerShell as an administrator and execute   $BitLocker = Get-BitLockerVolume -MountPoint $env:SystemDrive $RecoveryProtector = $BitLocker.KeyProtector | Where-Object { $_.KeyProtectorType -eq 'RecoveryPassword' }  BackupToAAD-BitLockerKeyProtector -MountPoint $env:SystemDrive -KeyProtectorId $RecoveryProtector.KeyProtectorID   It will send System drive recovery key to AAD! What if there are other encrypted fixed drives? A little more scripting is necessary   #Logs folder $OperatingFolder = 'C:\\Program Files (x86)\\Microsoft\\Temp' #Interate through all fixed drives and create object representations try {     $GetDeviceVolumes = Get-Volume | Where-Object { $PSItem.DriveType -eq 'Fixed' } | Select-Object DriveLetter | Where-Object { $PSItem.DriveLetter -ne $null }     $RecoveryPasswordsArray = @()     foreach ($Volume in $GetDeviceVolumes.DriveLetter) {         New-Variable \"GetRecoveryPasswordsFor$Volume\" -Force | Out-Null         Set-Variable -Name $(\"GetRecoveryPasswordsFor$Volume\") -Value $((Get-BitLockerVolume -MountPoint $volume`: -ErrorAction Stop).Keyprotector | Where-Object {                 $PSItem.KeyProtectorType -eq 'RecoveryPassword'             })         $RecoveryPasswordsArray += Get-Variable \"GetRecoveryPasswordsFor$Volume\"     } } catch {     $_ | Out-File $OperatingFolder\\bitlockerbackup.error } #for every found drive perform backup foreach ($Keys in $RecoveryPasswordsArray) {     if ($null -eq $Keys.Value) {         Continue     } else {         $KeysCount = ($Keys.Value | Measure-Object).Count         try {             if ($KeysCount -gt 1) {                 foreach ($Password in $Keys.Value.GetEnumerator()) {                     BackupToAAD-BitLockerKeyProtector -MountPoint \"$($Keys.Name[-1])`:\" -KeyProtectorId $Password.KeyProtectorId -ErrorAction Stop | Out-Null                     Write-Output 'Key sent'                     'Key sent' | Out-File $OperatingFolder\\bitlockerbackup.ok                 }             } else {                 BackupToAAD-BitLockerKeyProtector -MountPoint \"$($Keys.Name[-1])`:\" -KeyProtectorId $Keys.Value.KeyProtectorId -ErrorAction Stop | Out-Null                 Write-Output 'Key sent'                 'Key sent' | Out-File $OperatingFolder\\bitlockerbackup.ok             }         } catch {             Write-Output 'Error during backup'             $_ | Out-File $OperatingFolder\\bitlockerbackup.error             Exit 1         }     } }   Recovery keys are stored in device blade in AAD also in MEM portal         Additionally you can search for key by providing its ID here      Graph API   Prerequisites   In november 2020 Microsoft provided beta API to list all keys and get key details using Microsoft Graph. Well‚Ä¶at last!üòë Click here to jump to documentation.   I‚Äôm interested in listing all recovery keys in AAD. To be able to do that you need specific set of permissions      As you can see these are Delegated permissions so you will need combination of user role and cloud app ü§ù Start with creating user and assign one of the roles from above. For increased security use Azure KeyValut for password rotation or my privileged service account solution to increase protection even further üîë   Next step is creating app registration for Microsoft Graph calls. Go to apps and click on New registration      Enter app name and register      Next step is to add permissions for your app         Remember to grant admin consent         NOTE: You can remove default API permissions    You will also need client secret to be able to authenticate.      Copy secret immediately üëà   Powershell runbook   Now that we have everything in place you can proceed with scripting! To be able to use Microsoft Graph API with Delegated user permissions you need to generate Oauth2 token. Here is how to do that   #Client and user data $AccountName = \"username@onmicrosoft.com\" $AccountPassword = 'XXXXXXXXXXXXX' $ClientId = \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\" $ClientSecret = 'XXXXXXXXXXXXXXXXXXXXXX' $TenantID = \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\" $GraphUri = 'https://graph.microsoft.com' $GraphVersion = 'beta'  # Authentication url $AzureResourceURI = \"https://login.microsoftonline.com/$TenantID/oauth2/v2.0/token\"  # Construct the Body for the POST $Body = \"grant_type=password\"`  + \"&amp;username=\" + $Accountname `  + \"&amp;client_id=\" + $ClientId `  + \"&amp;client_secret=\" + $ClientSecret`  + \"&amp;password=\" + $AccountPassword `  + \"&amp;scope=https://graph.microsoft.com/.default\"  # The result should contain a token for use with Graph $Response = Invoke-WebRequest -Uri $AzureResourceURI -Method POST -Body $Body -UseBasicParsing $ResponseJSON = $Response | ConvertFrom-Json  # Add the token to headers for the Graph request $Headers = @{ Authorization = \"Bearer \" + $ResponseJSON.access_token }  #Run API call $Deviceuri = \"$GraphUri/$GraphVersion/devices\" $AllDevices = Invoke-RestMethod -Uri $Deviceuri -Headers $Headers -Method Get   OBVIOUSLY you should not keep your passwords and secrets as plain text in script!! It‚Äôs better to use variables or credentials in Automation Account üòâ With such generated token you can proceed and make API call for bitlocker recovery keys   #Required header modification for bitlocker call $Bitlockerheader = @{   'Authorization'      = $Headers.Authorization   'ocp-client-name'    = 'Bitlocker Recovery Keys'   'ocp-client-version' = '1.2' }  $bitlockerkeys = @() $Bitlockeruri = \"$GraphUri/$GraphVersion/bitlocker/recoveryKeys\" $bitlockerkeysuri = Invoke-RestMethod -Uri $Bitlockeruri -Headers $Bitlockerheader -Method Get $bitlockerkeys += $bitlockerkeysuri.value while ($bitlockerkeysuri.'@odata.nextLink') {  $NextBatchRequest = $bitlockerkeysuri.'@odata.nextLink'  $bitlockerkeysuri = Invoke-RestMethod -Uri $NextBatchRequest -Headers $Bitlockerheader -Method Get  $bitlockerkeys += $bitlockerkeysuri.value }      NOTE: As stated in documentation header requires ocp-client-name and ocp-client-version    As an result you will receive list of keys      Alright we‚Äôve got it! But how about taking it further‚Ä¶just bear with me a little more üòÅ   Proactive backup with Intune   Now that you have insights into state of bitlocker recovery keys in AAD you can take action if any device is missing a key. Start with creating PowerShell script deployment using Intune. Go to devices | scripts and create new Windows 10 configuration. Fill out the name and upload your backup script covered in first section of this post      Assign some AAD group and finish      Assign additional permissions to your application:      Device.Read.All   GroupMember.ReadWrite.All   Device read will help you out identify devices by their names and interate through all Windows 10 devices managed by Intune. Group member is required for modifications of group which is assigned to Intune script profile. Now go to your runbook and expand it with following code   # Get all AAD devices and filter out Windows managed by Intune $AllDevices = @() $Deviceuri = \"$GraphUri/$GraphVersion/devices?`$filter=operatingSystem eq 'Windows' AND isManaged eq true AND accountEnabled eq true\" $Devices = Invoke-RestMethod -Uri $Deviceuri -Headers $Headers -Method Get $AllDevices += $Devices.value while ($Devices.'@odata.nextLink') {  $NextBatchRequest = $Devices.'@odata.nextLink'  $Devices = Invoke-RestMethod -Uri $NextBatchRequest -Headers $Headers -Method Get  $AllDevices += $Devices.value } $AllDevices = $AllDevices | Where-Object { $PSItem.managementType -eq 'MDM' -and $PSItem.approximateLastSignInDateTime -gt $(Get-Date).AddMonths(-3) }  # Check group members $BackupIntuneScriptGroup = 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX' $Groupuri = \"$GraphUri/$GraphVersion/groups/$BackupIntuneScriptGroup/members\" $GroupMembers = Invoke-RestMethod -Uri $Groupuri -Headers $Headers -Method Get  # For every managed device check if there is a recovery key in AAD $Results = @() try {  foreach ($device in $AllDevices) {   if (($bitlockerkeys | Where-Object { $PSItem.deviceId -eq $device.deviceId } | Measure-Object).Count -gt 0) {    if ($device.deviceId -in $GroupMembers.value.deviceId) {     $GroupHeader = @{      Authorization = $Headers.Authorization     }     $Response = Invoke-RestMethod -Method DELETE -Uri \"$GraphUri/$GraphVersion/groups/$BackupIntuneScriptGroup/members/$($device.id)/`$ref\" -Headers $GroupHeader     $Results += [PSCustomObject]@{      DeviceName       = $device.displayName      DeviceId         = $device.deviceId      RecoveryKeyInAAD = $true      Action           = 'Removed from group'      AdditionalInfo   = \"$(($bitlockerkeys | Where-Object { $PSItem.deviceId -eq $device.deviceId } | Measure-Object).Count) keys found\"     } | ConvertTo-Json    } else {     $Results += [PSCustomObject]@{      DeviceName       = $device.displayName      DeviceId         = $device.deviceId      RecoveryKeyInAAD = $true      Action           = 'None'      AdditionalInfo   = \"$(($bitlockerkeys | Where-Object { $PSItem.deviceId -eq $device.deviceId } | Measure-Object).Count) keys found\"     } | ConvertTo-Json    }   } else {    if ($device.displayName -in $GroupMembers.value.displayName) {     $Results += [PSCustomObject]@{      DeviceName       = $device.displayName      DeviceId         = $device.deviceId      RecoveryKeyInAAD = $false      Action           = 'None'      AdditionalInfo   = 'Already in group'     } | ConvertTo-Json    } else {     $BodyContent = @{      \"@odata.id\" = \"$GraphUri/$GraphVersion/devices/$($device.id)\"     } | ConvertTo-Json     $GroupHeader = @{      Authorization  = $Headers.Authorization      'Content-Type' = 'application/json'     }      $Response = Invoke-RestMethod -Method POST -Uri \"$GraphUri/$GraphVersion/groups/$BackupIntuneScriptGroup/members/`$ref\" -Headers $GroupHeader -Body $BodyContent     $Results += [PSCustomObject]@{      DeviceName       = $device.displayName      DeviceId         = $device.deviceId      RecoveryKeyInAAD = $false      Action           = 'Added to backup group'      AdditionalInfo   = ''     } | ConvertTo-Json    }   }  } } catch {  Write-Error $device  Write-Error $_  break }   Output      Summary   Thanks to Microsoft Graph API you can run check against Azure AD for bitlocker recovery keys. If some device is missing a key Intune will take care of performing backup for you. Now you can rest without worries.   See you in next! üòâ üß†  ","categories": ["Powershell"],
        "tags": ["Intune","AzureAD","Powershell","Microsoft Graph","Encryption","Workstations","Runbook"],
        "url": "http://localhost:4000/powershell/Graph-Bitlocker/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Upload files with Intune to Azure file share",
        "excerpt":"Intro   Getting logs for troubleshooting deployments and configurations driven by Intune may be difficult when device is off-prem (which nowadays is most of the times). In this post I will show you how to create Azure file share, map it as network drive and make Intune do the copying. ‚òÅ   Azure file share   Creating Azure file share is very simple! Go to portal azure and fil lout required boxes      After storage account is deployed navigate to Overview and then File shares:      Create new file share      Enter desired name, quota and click create      Go to created share and click on connect      You will get Powershell which performs connection test to the share over 445 port, saves credentials for it and permanently maps drive for you. In this solution permanent mapping is not necessary so you will need to make some modifications this script.   $connectTestResult = Test-NetConnection -ComputerName intunelogssmb.file.core.windows.net -Port 445 $Password = 'AutomaticallyGeneratedAccessKey' $secret = ConvertTo-SecureString $Password -AsPlainText -Force $psCred = New-Object System.Management.Automation.PSCredential -ArgumentList ('Azure\\intunelogssmb', $secret) if ($connectTestResult.TcpTestSucceeded) {     # Mount the drive     New-PSDrive -Name W -PSProvider FileSystem -Root \"\\\\intunelogssmb.file.core.windows.net\\logs\" -Credential $psCred } else {     Write-Error -Message \"Unable to reach the Azure storage account via port 445. Check to make sure your organization or ISP is not blocking port 445, or use Azure P2S VPN, Azure S2S VPN, or Express Route to tunnel SMB traffic over a different port.\" }   In my environment I‚Äôve came upon issue while trying to map disc using method from above. My issue was that HKLM:SYSTEM\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel was set to 1. After I‚Äôve changed it to 3 it worked! üòÑ  For additional troubleshooting visit docs.   Copy logs using Intune   To deploy Powershell script with Intune you can create Powershell script profile or Win32 App (which is my personal favorite). If you want to learn more about deploying Powershell scripts using Win32 App stop here and checkout my previous post - Harness Intune Win32 app installer - I will wait‚Ä¶ ‚åö   3   2   1   Back already? Cool so let‚Äôs continue! Begin with creating your Powershell script. Feel free to use my template. For example if you want to generate mdmdiagnostics and upload them to your file share it would look like:   # Parameters $Tag = 'IntuneLogs' $OperatingFolder = 'C:\\Program Files (x86)\\Microsoft\\Temp' $InstallFailCode = 1618 $InstallSuccessCode = 1707  # Log $LogFile = \"$OperatingFolder\\IntuneSoftwareInstall.log\" $LogFileError = \"$OperatingFolder\\IntuneSoftwareInstallError.log\"  #Info . $PSScriptRoot\\Write-FileLog.ps1  #Custom exit function Exit-WithCode {  param  (   $exitcode  )   $host.SetShouldExit($exitcode) } ####################################################################### #Check for folder If (Test-Path -Path $OperatingFolder -PathType Container) {  Write-FileLog -FunctionStart -LogFile $LogFile } Else {  New-Item -Path $OperatingFolder -ItemType Directory  Write-FileLog -Message \"$OperatingFolder created\" -LogFile $LogFile }  #Process Write-FileLog -FunctionStart -LogFile $LogFile Try {  Write-FileLog -Message \"Mounting network drive\" -LogFile $LogFile  $connectTestResult = Test-NetConnection -ComputerName intunelogssmb.file.core.windows.net -Port 445  $Password = 'AutomaticallyGeneratedAccessKey'  $secret = ConvertTo-SecureString $Password -AsPlainText -Force  $psCred = New-Object System.Management.Automation.PSCredential -ArgumentList ('Azure\\intunelogssmb', $secret)  if ($connectTestResult.TcpTestSucceeded) {   # Mount the drive   New-PSDrive -Name W -PSProvider FileSystem -Root \"\\\\intunelogssmb.file.core.windows.net\\logs\" -Credential $psCred  } else {   Write-FileLog -Type Error -Message \"Unable to reach the Azure storage account via port 445\" -LogFileError $LogFileError   Exit-WithCode -exitcode $InstallFailCode  }  Write-FileLog -Message \"Generating mdmdiagnostics\" -LogFile $LogFile  MdmDiagnosticsTool.exe -area 'Autopilot;DeviceEnrollment;DeviceProvisioning;TPM' -zip \"$OperatingFolder\\mdmdiagnostics.zip\"  Write-FileLog -Message \"Uploading logs to file share\" -LogFile $LogFile  Move-Item -Path \"$OperatingFolder\\mdmdiagnostics.zip\" -Destination W:\\ -Force } Catch {  Write-FileLog -Type Error -Message \"Script ERROR\" -LogFileError $LogFileError  $_ | Out-File -FilePath $LogFileError -Append -Encoding ASCII  Write-FileLog -Type Warn -Message \"Script TERMINATION\" -LogFileError $LogFileError  Write-FileLog -Type Warn -Message \"Exitcode $InstallFailCode\" -LogFileError $LogFileError  Exit-WithCode -exitcode $InstallFailCode }   To test your script it‚Äôs the best to use Intune-App-Sandbox - great tool to test Powershell scripts in Windows Sandbox in a matter of seconds!   After your package successfully passed the test you can create deployment profile! Upload .intunewin file and enter install command      For detection let‚Äôs check for our file in networkshare      Complete the rest of configuration and you are ready! To access uploaded logs just map this file share on your device üòé      Summary   I love it! It‚Äôs so brilliant in it‚Äôs simplicity! I hope that it will help you with gartering required files from endpoints. See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Azure","Powershell"],
        "url": "http://localhost:4000/intune/Intune-Logs-SMB/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Create powerful dashboards with Azure Workbooks",
        "excerpt":"Intro   What value brings maintenance if we do not monitor its results? In this post I will show you how you can easily create Azure workbook with data from Log analytics. üìä   The data we will take a look at are generated by runbook from this post - Verify Azure AD Bitlocker Keys with Microsoft Graph. One last thing‚Ä¶I‚Äôve updated code in that post to provide more useful data and seamless compliance with log analytics.   Log analytics   Log Analytics is a tool in the Azure portal to edit and run log queries from data collected by Azure Monitor Logs and interactively analyze their results. You can use Log Analytics queries to retrieve records matching particular criteria, identify trends, analyze patterns, and provide a variety of insights into your data. To be able to understand and create your own queries you will need to get familiar with Kusto query language (KQL).   For that and more visit - Log Analytics tutorial.   The fastest way to read outputs from your runbooks is to enable diagnostic settings. Navigate to your automation account and proceed with adding new diagnostic settings:      Then, enter name for your setting and choose log analytics workspace:      Sending and processing data for the first time might take some time so go grab a cup of your favorite drink üòâ When ready, navigate to your logs workspace and try to run that simple query:      If you see data it means that you can proceed with expanding your query! Logs contain data generated by all your runbooks within automation account connected to this workspace. Firstly you will need to filter through runbookname and then category because we are interested only in script output   AzureDiagnostics  | where RunbookName_s == \"BitlockerRecoveryKeysMaintenance\" | where Category == \"JobStreams\"   Raw output has a lots of currently unnecessary data and the good stuff is wrapped in JSON in column ResultDescription. Expand this JSON and show only columns that I want ‚ú®:   | extend DeviceName = tostring(parse_json(ResultDescription).DeviceName) | extend ReferenceId = tostring(parse_json(ResultDescription).DeviceId) | extend RecoveryKeyInAAD = tostring(parse_json(ResultDescription).RecoveryKeyInAAD) | extend Action = tostring(parse_json(ResultDescription).Action) | extend AdditionalInfo = tostring(parse_json(ResultDescription).AdditionalInfo) | project DeviceName,UserName,RecoveryKeyInAAD,Action,AdditionalInfo,AADDeviceId = ReferenceId,DeviceId,TimeGenerated   With those simple steps you have got nicely formatted table with results of maintenance task:      Azure workbook   Opening log analytics every time and paste some query to analyse data is not for me‚Ä¶thankfully you can create workbook which will allow you to see that data instantaneously and do much more!   Go to Azure Monitor, then Workbooks:      There you will find some templates and you can also browse gallery or search through community github repo. This helps a lot at the beginning üòâ When ready create a new workbook!      You can start with providing some description      Next, add parameter section. It allows you to easily manipulate data and visualizations that are presented in your report.      Parameters can take many different types, for this report you will need:      textbox - for searching string   dropdown (JSON) - for filtering true/false values   dropdown (KQL) - for filtering dates of maintenance if they are custom   While first two are rather simple the last one might be tricky. Here take a look how it can be done:   AzureDiagnostics  | where TimeGenerated &gt; ago(30d)  | where RunbookName_s == \"BitlockerRecoveryKeysMaintenance\" | where Category == \"JobStreams\" | extend DeviceName_ = tostring(parse_json(ResultDescription).DeviceName) | extend DeviceId_ = tostring(parse_json(ResultDescription).DeviceId) | extend RecoveryKeyInAAD_ = tostring(parse_json(ResultDescription).RecoveryKeyInAAD) | extend Action_ = tostring(parse_json(ResultDescription).Action) | extend AdditionalInfo_ = tostring(parse_json(ResultDescription).AdditionalInfo) | project Date = format_datetime(TimeGenerated,'yyyy/MM/dd') | summarize by Date | sort by Date desc      Now you can create query section and use KQL from previous paragraph to search for maintenance results. Remember to choose correct workspace as source point of your data!      Query:   AzureDiagnostics  | where format_datetime(TimeGenerated,'yyyy/MM/dd') in ({Date})  | where RunbookName_s == \"BitlockerRecoveryKeysMaintenance\" | where Category == \"JobStreams\" | extend DeviceName = tostring(parse_json(ResultDescription).DeviceName) | extend ReferenceId = tostring(parse_json(ResultDescription).DeviceId) | extend RecoveryKeyInAAD = tostring(parse_json(ResultDescription).RecoveryKeyInAAD) | extend Action = tostring(parse_json(ResultDescription).Action) | extend AdditionalInfo = tostring(parse_json(ResultDescription).AdditionalInfo) | join IntuneDevices on ReferenceId | project DeviceName,UserName,RecoveryKeyInAAD,Action,AdditionalInfo,AADDeviceId = ReferenceId,DeviceId,TimeGenerated | where DeviceName startswith \"{DeviceName}\" and RecoveryKeyInAAD in ({RecoveryKey}) | distinct *      NOTICE that using parameters in KQL query is as simple as providing paramter name in {Name}    In query above I‚Äôm also loading data from log analytics containing details fetched from Intune Data Warehouse. You should be able to see results in form of table:      Another great feature of azure workbooks is that you can create actions within report! Lets say that you want to select device on a list and take a quick look on it in Intune console.   YES YOU CAN üòÅ   Start with modifying query section to allow it to export data as parameters:         Now, create a new section of type links/tabs, select action custom view and tick context pane box:      In configuration pane for custom view choose url and pase this   https://portal.azure.com/#blade/Microsoft_Intune_Devices/DeviceSettingsBlade/overview/mdmDeviceId/      After you click initialize your view should look like that:      And when you select device from list you will be able to invoke button action that will open device details ü•≥:      Summary   Right now Azure workbooks are my favorite tool to play with data visualization and drawing a conclusions based on what I see.   I will probably end up with whole dashboard build from workbooks!!   See you in next! üòâ üß†  ","categories": ["Azure"],
        "tags": ["Intune","AzureMonitor","LogAnalytics","Encryption","Workstations","AzureWorkbook"],
        "url": "http://localhost:4000/azure/Azure-workbook/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Have a cake and eat it too",
        "excerpt":"Intro   Let‚Äôs say you wish to restrict users from sending files via bluetooth üì° but without disable bluetooth itself, also allowing to use headset üéß. You can archive it using wide variety of tools but here you shall learn how to do it using Intune!   Attack surface reduction   Even using Intune you can apply restrictions through two different blades. Thou you can do it through Devices-&gt;Windows-&gt;Configuration Profiles you should start to get used to using Endpoint Security tab ‚Äòcause #MEMTeam is heavily investing into that area.   To create bluetooth (and more) restrictions policies go to MEM console =      Enter name and description for your policy      Scroll down to the bluetooth settings. At first sigh there are 5 switches to toy with but at the very end you can see Bluetooth allowed services. That‚Äôs where the magic ‚ú® happens!      On that list you specify UUIDs of allowed bluetooth protocol services. These UUIDs all use the same base UUID with the profile identifiers added to the beginning of the base UUID. For example   Hands Free Profile UUID = base UUID + 0x111E to the beginning = 0000111E-0000-1000-8000-00805F9B34FB   To discover all services please refer to service discovery.   Your list allowing to use headsets with microphones, mice and keyboard will look like:   00001108-0000-1000-8000-00805F9B34FB 0000110B-0000-1000-8000-00805F9B34FB 0000110E-0000-1000-8000-00805F9B34FB 0000110F-0000-1000-8000-00805F9B34FB 0000110c-0000-1000-8000-00805f9b34fb 00001112-0000-1000-8000-00805f9b34fb 0000111E-0000-1000-8000-00805F9B34FB 0000111f-0000-1000-8000-00805f9b34fb 00001124-0000-1000-8000-00805F9B34FB 00001131-0000-1000-8000-00805F9B34FB 00001200-0000-1000-8000-00805F9B34FB 00001203-0000-1000-8000-00805F9B34FB 00001800-0000-1000-8000-00805F9B34FB 00001801-0000-1000-8000-00805F9B34FB 0000180A-0000-1000-8000-00805F9B34FB 00001812-0000-1000-8000-00805F9B34FB 00001813-0000-1000-8000-00805F9B34FB   It contains all services UUIDs related to voice &amp; music and keyboards and mice. Save that list as an .csv file and click Import.         Now you can apply policy to your test machine and see if it works üòâ.   Find more UUIDs   When restriction such as above is applied there is always slight chance that you missed something or there are thing that you were not aware of!   To find devices that are blocked by policy you can simply open Device manager on the device and search for items with ‚ö† next to the icon. When you go into details you might see something like:      Then go to details and search for service UUID. Seems like a few steps‚Ä¶ Worry not, PowerShell will help you with fetching required data. Just run:   $Devices = Get-PnpDevice | where {$psitem.status -eq 'Error'} | sort friendlyname   And you will get immediately full list of the devices. On that list you are interested in property InstanceId.      That ID contains bluetooth service UUID which can be added to Intune policy which will lead to resolving issue with this device.   Summary   Such approach to handling bluetooth restrictions looks to me to be very clever.   Having possibility to use unique identifiers to tweak policies (and don‚Äôt bother is it ABC3000 or XYZ9000) makes life easier!   Thanks IEEE 802.15 and Microsoft   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","Workstations","Endpoint","Security"],
        "url": "http://localhost:4000/intune/Bluetooth/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Reenroll HAADJ Device to Intune",
        "excerpt":"Intro   Hey!   I will start with notice that this method should be your last resort in fixing the problem with lost device in Intune or when sync ends with sync could not be initiated 0x80072f0c.   Based on this post - link - I‚Äôve created script to run on affected device to jump start enrollment again.   You will find it in the section below.  The Script   So this is it:   $Global:ErrorActionPreference = 'Stop' Write-Host \"Stopping Intune Service\" -ForegroundColor Yellow Get-Service *intune* | Stop-Service Write-Host \"Check if device is AAD Joined\" -ForegroundColor Yellow $DSREGCMD = dsregcmd /status $AADJoinCheck = $null $AADJoinCheck = $DSREGCMD | Select-String -Pattern 'AzureAdJoined : YES' if ($null -eq $AADJoinCheck) { \tWrite-Host \"Device is not AAD Joined!!! Stopping!\" -ForegroundColor Red \tBreak } else { \tWrite-Host \"Device is AAD Joined - OK\" -ForegroundColor Green } Write-Host \"Searching for enrollment ID\" $Tasks = Get-ScheduledTask | Where-Object { $psitem.TaskPath -like \"\\Microsoft\\Windows\\EnterpriseMgmt\\*\" } $EnrollId = $Tasks[0].TaskPath.Split('\\\\')[-2] if ($EnrollID -match '\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12}') { \tWrite-Host \"Found EnrollID - $EnrollID\" -ForegroundColor Green } else { \tWrite-Host \"Error parsing EnrollID. Stopping\" -ForegroundColor Red \tBreak } Write-Host \"Removing scheduledTasks\" -ForegroundColor Yellow Try { \t$Tasks | ForEach-Object { Unregister-ScheduledTask -InputObject $psitem -Verbose -Confirm:$false } } catch { \tThrow $_.Exception.Message } Write-Host \"Done\" -ForegroundColor Green Write-Host \"Trying to remove tasks folder\" -ForegroundColor Yellow $TaskFolder = Test-Path \"C:\\windows\\System32\\Tasks\\Microsoft\\Windows\\EnterpriseMgmt\\$EnrollID\" try { \tif ($TaskFolder) { \t\tRemove-Item -Path \"C:\\windows\\System32\\Tasks\\Microsoft\\Windows\\EnterpriseMgmt\\$EnrollID\" -Force -Verbose  \t} } catch { \tThrow $_.Exception.Message } Write-Host \"Removing registry keys\" -ForegroundColor Yellow $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\Enrollments\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Enrollments\\$EnrollID -Recurse -Force -Verbose  } $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\Enrollments\\Status\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Enrollments\\Status\\$EnrollID -Recurse -Force -Verbose  } $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\EnterpriseResourceManager\\Tracked\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\EnterpriseResourceManager\\Tracked\\$EnrollID -Recurse -Force -Verbose  } $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\PolicyManager\\AdmxInstalled\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\PolicyManager\\AdmxInstalled\\$EnrollID -Recurse -Force -Verbose  } $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\PolicyManager\\Providers\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\PolicyManager\\Providers\\$EnrollID -Recurse -Force -Verbose  } $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\Provisioning\\OMADM\\Accounts\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Provisioning\\OMADM\\Accounts\\$EnrollID -Recurse -Force -Verbose  } $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\Provisioning\\OMADM\\Logger\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Provisioning\\OMADM\\Logger\\$EnrollID -Recurse -Force -Verbose  } $EnrollmentReg = Test-Path -Path HKLM:\\SOFTWARE\\Microsoft\\Provisioning\\OMADM\\Sessions\\$EnrollID if ($EnrollmentReg) { \tRemove-Item -Path HKLM:\\SOFTWARE\\Microsoft\\Provisioning\\OMADM\\Sessions\\$EnrollID -Recurse -Force -Verbose  } ##### Run this if Remove-Item -Path \"C:\\windows\\System32\\Tasks\\Microsoft\\Windows\\EnterpriseMgmt\\$EnrollID\" -Force -Verbose FAILED &lt;# $EnrollmentReg = Test-Path -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\Microsoft\\Windows\\EnterpriseMgmt\\$EnrollID\" if ($EnrollmentReg) { \tRemove-Item -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\Microsoft\\Windows\\EnterpriseMgmt\\$EnrollID\" -Recurse -Force -Verbose  } #&gt; Write-Host \"Checking for Intune MDM cert\" -ForegroundColor Yellow $Certs = $null $Certs = Get-ChildItem -Path cert:\\LocalMachine\\My | Where-Object { $psitem.issuer -like '*Intune*' } if ($null -ne $Certs) { \t$(Get-Item ($Certs).PSPath) | Remove-Item -Force -Verbose  \tWrite-Host \"Removed\" -ForegroundColor Green } else { \tWrite-Host \"Not found\" -ForegroundColor Yellow } Write-Host \"Downloading psexec\" -ForegroundColor Yellow Invoke-RestMethod -Uri 'https://download.sysinternals.com/files/PSTools.zip' -OutFile $env:TEMP\\PSTools.zip Write-Host \"Expanding psexec\" -ForegroundColor Yellow Expand-Archive -Path $env:TEMP\\PSTools.zip -DestinationPath $env:TEMP\\PSTools -Force Write-Host \"Starting psexec with AutoEnrollMDM\" -ForegroundColor Yellow $Process = Start-Process -FilePath $env:TEMP\\PSTools\\psexec.exe -ArgumentList \"-i -s -accepteula cmd  /c `\"deviceenroller.exe /c /AutoEnrollMDM`\"\" -Wait -NoNewWindow -PassThru if ($process.ExitCode -eq 0) { \tWrite-Host \"Started AutoEnrollMDM\" -ForegroundColor Green  } else { \tWrite-Host \"Exit code 1. Please verify manually\" -ForegroundColor Red } if ((Get-Service *intune*).Status -ne 'Running') { \tGet-Service *intune* | Start-Service }   First section is to check if the device is AAD joined. If it is not, script will terminate and you will need to fix that first. Try running:   dsregcmd /join   Be sure to run this in SYSTEM context. If no issue is found in AAD join you will need to find enrollment ID. It will be needed for finding and wiping registry keys. If no enrollment ID is found script will terminate and I recommend doing re-enrollment with standard method which is disconnecting device from domain and reconnecting.   With enrollment ID you can now un-register scheduledTasks that reside in EnterpriseMgmt folder. Then remove the folder itself.   Next you will be searching for registry keys that match enrollment ID and then deleting them. There also should be a MDM certificate in Personal vault but if its not there then do not worry (if there is, remove it).   Now that you have cleared all traces of enrollment you will need psexec to impersonate SYSTEM to jump start enrollment. Download it, extract the psexec from archive and run it:   psexec.exe -i -s -accepteula cmd   Then in the new window you can begin enrollment   deviceenroller.exe /c /AutoEnrollMDM   All the things that you deleted will be recreated and new enrollment ID will be assigned. After minute or so you will see device in Intune portal again.   Summary   While this method is not supported I‚Äôve reconnected 3 devices using this script and it worked. So if you are at the dead end may it serve you well!   See you in next! üòâ üß†  ","categories": ["Powershell"],
        "tags": ["Intune"],
        "url": "http://localhost:4000/powershell/Reenroll/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "How to bypass Settings catalog limitation",
        "excerpt":"Intro   Configuring Intune MDM polices sometimes is tricky. Especially when you are migrating baseline Group Policies. First of all, do not migrate everything AS IS üò£. Take a look at the Microsoft Security Baseline, tweak it to your needs, apply it to some pilot group and then build-up.   But what‚Äôs about Settings catalog limitation?   List of items   I want to configure Allow cookies on specific sites and with help of Settings catalog it seems fairly easy! üòé            There you can enter desired sites or import whole bunch of them. In my case I‚Äôm going to import over 100 dummy sites üòè.      Click Next, assign, create!   Wait what!? ü§®      As you may guess now I know what‚Äôs the issue but it was not so obvious from the start‚Ä¶ There is a limit of 100 items on that list‚Ä¶   Alright let‚Äôs create one policy with 100 and then another policy with the rest! üí°   Nope‚Ä¶as soon as policies are digested by the device it reports with Conflict status!   What now? ü§î   Custom policy   It must be possible to implement such long and probably even longer list! I‚Äôve started to search for OMA-Uri for that setting. And found it - ./Vendor/MSFT/Policy/Config/microsoft_edge~Policy~microsoft_edge~ContentSettings/CookiesAllowedForUrls   Now for creating custom policy      Enter desired name for policy and continue      Now what should I do with Value ??   I‚Äôve created policy with a few urls using Settings catalog and applied them to the device. Then I took a look at the events from DeviceManagement-Enterprise-Diagnostics-Provider and found out that value should look like   &lt;enabled/&gt;&lt;data id=\"CookiesAllowedForUrlsDesc\" value=\"1 [*.]cemLT.pl 2 [*.]asdrW.pl\"/&gt;   Not bad.   But!   This separation between number, link and another item is not SPACE BAR ‚ùó‚ùó It is special character encoded as &amp;#xF000;, and with that it all should be glued   &lt;enabled/&gt;&lt;data id=\"CookiesAllowedForUrlsDesc\" value=\"1&amp;#xF000;[*.]cemLT.pl&amp;#xF000;2&amp;#xF000;[*.]asdrW.pl\"/&gt;   Knowing that, finally I can create my policy with 100 and more items!   Dummy items   For my dev environment I‚Äôve created this teeny-tiny script to generate some dummy urls for this policy:   $String = for($i=1;$i-lt 104;$i++){  \"$i&amp;#xF000;[*.]$(-join ((65..90) + (97..122) | Get-Random -Count 5 | ForEach-Object {[char]$_})).pl&amp;#xF000;\" } $String -join ''   Summary   I hope that I‚Äôve helped you with this tip! You won‚Äôt find any information in MS Docs about such limitation‚Ä¶   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","MDM","MicrosoftEdge"],
        "url": "http://localhost:4000/intune/Edge-allowed-cookies/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "How to easily move Settings Catalog profile",
        "excerpt":"Intro   As the saying goes‚Ä¶do not develop/test on production‚Ä¶so we (IT Pros) work on some kind of sandbox environment. This comes with pros and cons but that is not what I particularly want to focus on (though it is kind of connected with cons).   Let me show you how I‚Äôve leveraged a neat trick that I‚Äôve learned during one of the Ignite sessions last year! ‚ù§Ô∏è‚Äçüî•   Edge DevTools   You may know or not but Microsoft Endpoint Manager admin center is heavily dependent on Graph API calls! When you go to any section, open configuration profile, create new one, wipe device, export report or whatever you name it, underneath you are calling Microsoft Graph API call.   For me it is awesome because I do not need to go to Microsoft Docs to search what Graph Uri I need to do X or Y. I just need to open Edge DevTools and make an action through admin center portal.   To open DevTools just press F12 or CTRL + SHIFT + I on your keyboard. Then go to Network      There you will be able to see traffic that comes and goes but that is not all! ü§î      At the beginning it might be all gibberish      But use Filter bar and all becomes much better      Now that we have only request that have some value for us let‚Äôs pick first one and see what it does. When you go to request details you can see exact Graph API URL that was sent to get the data for a blade.      After you determine which request is the one that you are interested in now it is time for promised trick!!!   Right click on request and navigate to Copy and there you have it: Copy as PowerShell üöÄ      PowerShell Request   From now on you are a Intune Microsoft Graph Master üòÅ   Let‚Äôs see what hides in copied code‚Ä¶   $session = New-Object Microsoft.PowerShell.Commands.WebRequestSession $session.UserAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50\" Invoke-WebRequest -UseBasicParsing -Uri \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('0d15031a-fd95-4202-a43d-da63117070b8')\" ` -WebSession $session ` -Headers @{ \"x-ms-client-session-id\"=\"97b2957ca94944f1bf9b5990939c04b0\"   \"X-Content-Type-Options\"=\"nosniff\"   \"Accept-Language\"=\"en\"   \"Authorization\"=\"Bearer eyJ0eXAiOiJKV1QiLCJub25jZSI6Im5idkVmeXd2RExnSjJaMG9BdlRna0xMTmFvREZYdHJHSlRLUEZ1cEdEZ00iLCJhbGciOiJSUzI1NiIsIng1dCI6Ik1yNS1BVWliZkJpaTdOZDFqQmViYXhib1hXMCIsImtpZCI6Ik1yNS1BVWliZkJpaTdOZDFqQmViYXhib1hXMCJ9.eyJhdWQiOiJodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vIiwiaXNzIjoiaHR0cHM6Ly9zdHMud2luZG93cy5uZXQvYTUxZDgyNzYtYThjYS00NmEyLTg3NjUtYjE2ZjJmN2U1ZTZhLyIsImlhdCI6MTY0NDY3NjYzMiwibmJmIjoxNjQ0Njc2NjMyLCJleHAiOjE2NDQ2ODE5MzYsImFjY3QiOjAsImFjciI6IjEiLCJhaW8iOiJFMlpnWUJEWWVlYTZXdGlWN01mQ241ZHNXTFNpWlZQeE9nUHVob1ZjQVF6K01UL1pBK0lCIiwiYW1yIjpbInB3ZCJdLCJhcHBfZGlzcGxheW5hbWUiOiJNaWNyb3NvZnQgSW50dW5lIHBvcnRhbCBleHRlbnNpb24iLCJhcHBpZCI6IjU5MjZmYzhlLTMwNGUtNGY1OS04YmVkLTU4Y2E5N2NjMzlhNCIsImFwcGlkYWNyIjoiMiIsImNvbnRyb2xzIjpbImNhX2VuZiJdLCJmYW1pbHlfbmFtZSI6IkhvcmJhY3oiLCJnaXZlbl9uYW1lIjoiTWFjaWVqIiwiaWR0eXAiOiJ1c2VyIiwiaXBhZGRyIjoiODkuNjQuMTE5LjIxNCIsIm5hbWUiOiJNYWNpZWogSG9yYmFjeiIsIm9pZCI6ImNmMWYwNTI1LWQzMjYtNDVmMy1iYTBlLWZkMDhkYjA3OTM0ZSIsInBsYXRmIjoiMyIsInB1aWQiOiIxMDAzMjAwMDk2M0IwMzQ0IiwicmgiOiIwLkFVY0Fkb0lkcGNxb29rYUhaYkZ2TDM1ZWFnTUFBQUFBQUFBQXdBQUFBQUFBQUFCSEFMMC4iLCJzY3AiOiJDbG91ZFBDLlJlYWQuQWxsIENsb3VkUEMuUmVhZFdyaXRlLkFsbCBEZXZpY2VNYW5hZ2VtZW50QXBwcy5SZWFkV3JpdGUuQWxsIERldmljZU1hbmFnZW1lbnRDb25maWd1cmF0aW9uLlJlYWRXcml0ZS5BbGwgRGV2aWNlTWFuYWdlbWVudE1hbmFnZWREZXZpY2VzLlByaXZpbGVnZWRPcGVyYXRpb25zLkFsbCBEZXZpY2VNYW5hZ2VtZW50TWFuYWdlZERldmljZXMuUmVhZFdyaXRlLkFsbCBEZXZpY2VNYW5hZ2VtZW50UkJBQy5SZWFkV3JpdGUuQWxsIERldmljZU1hbmFnZW1lbnRTZXJ2aWNlQ29uZmlndXJhdGlvbi5SZWFkV3JpdGUuQWxsIERpcmVjdG9yeS5BY2Nlc3NBc1VzZXIuQWxsIGVtYWlsIG9wZW5pZCBwcm9maWxlIFNpdGVzLlJlYWQuQWxsIiwic3ViIjoiNkw5Q1hJeTRsckJPMGZ3RGVIaldCMDZUOGtLOXVBT3c2UnhLS0VYLTN0OCIsInRlbmFudF9yZWdpb25fc2NvcGUiOiJFVSIsInRpZCI6ImE1MWQ4Mjc2LWE4Y2EtNDZhMi04NzY1LWIxNmYyZjdlNWU2YSIsInVuaXF1ZV9uYW1lIjoibWFjaWVqaG9yYmFjekBkdW5lc2JveC5vbm1pY3Jvc29mdC5jb20iLCJ1cG4iOiJtYWNpZWpob3JiYWN6QGR1bmVzYm94Lm9ubWljcm9zb2Z0LmNvbSIsInV0aSI6ImllckFtVU9WMlVHQUd0c1RwdllQQUEiLCJ2ZXIiOiIxLjAiLCJ3aWRzIjpbImUzOTczYmRmLTQ5ODctNDlhZS04MzdhLWJhOGUyMzFjNzI4NiIsIjYyZTkwMzk0LTY5ZjUtNDIzNy05MTkwLTAxMjE3NzE0NWUxMCIsImU4NjExYWI4LWMxODktNDZlOC05NGUxLTYwMjEzYWIxZjgxNCIsImIwZjU0NjYxLTJkNzQtNGM1MC1hZmEzLTFlYzgwM2YxMmVmZSIsIjE5NGFlNGNiLWIxMjYtNDBiMi1iZDViLTYwOTFiMzgwOTc3ZCIsImI3OWZiZjRkLTNlZjktNDY4OS04MTQzLTc2YjE5NGU4NTUwOSJdLCJ4bXNfc3QiOnsic3ViIjoialU1SWVqSGU5MVpjcDlKdHZLNXV3aWJBN0d5SHZfRjUyMzJqa1dZdUFWYyJ9LCJ4bXNfdGNkdCI6MTU3OTI5NzMxNH0.SuWFMS0iGwVZkM_R1zdRMxOIE3N5Mjf2CQOom_0NHh3yKyS_Gl5FxFeeKcsBS8qkWdI7ybBONOLuoebGlLX69PyjTRnlqob8vHSe3h6DiSMwvMAuTE3GQ0yYMM-EMfN96gHIaDargVjknWb48k7CeQuS5b4I8aNuze-yhItZz0jSthucUXmQQtKWEvyh_HvQdcWMOGbYGaBCZDaTSoocek2FUh4bVli_bhfOkBSC2ZNRTXaZ0jvw27Giw3AB8wd70gPjKHKH-RsUmLhdlqdFGxWwX5sYZ_6JY2yTfIIDiZfVN8OpbyosG6XuUDPt02S\"   \"x-ms-effective-locale\"=\"en.pl-pl\"   \"Accept\"=\"*/*\"   \"Referer\"=\"\"   \"x-ms-client-request-id\"=\"780cb14a-0c3e-4d6b-9160-45f44f6c6ea4\"   \"client-request-id\"=\"780cb14a-0c3e-4d6b-9160-45f44f6c6ea4\" } ` -ContentType \"application/json\"   Not much! But all the juice is there üòé   First of all I always change Invoke-WebRequest to Invoke-RestMethod. This makes the request response data easier to handle üòâ   So we get Graph API URL, Authorization token and Body (if there is any). Those three components of this code are the Heros.   Move Settings Catalog profile   Finally it now the time for you to perform migration of Settings Catalog profile from Sandbox to Prod üòù   Until Microsoft adds a action to Export and Import configuration profiles it is the fastest way without installing any additional software!   To be able to move settings catalog profile between tenants we need set of policies and values that are configured in this profile.   So go to the profile that you wish to move and Edit profile      You do not need to make any changes!   Just click Review + save and Save to capture request that goes after you click Save.   $session = New-Object Microsoft.PowerShell.Commands.WebRequestSession $session.UserAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50\" Invoke-RestMethod -UseBasicParsing -Uri \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('0d15031a-fd95-4202-a43d-da63117070b8')\" ` -Method \"PUT\" ` -WebSession $session ` -Headers @{ \"x-ms-client-session-id\"=\"97b2957ca94944f1bf9b5990939c04b0\"   \"X-Content-Type-Options\"=\"nosniff\"   \"Accept-Language\"=\"en\"   \"Authorization\"=\"Bearer eyJ0eXAiOiJKV1QiLCJub25jZSI6Im5idkVmeXd2RExnSjJaMG9BdlRna0xMTmFvREZYdHJHSlRLUEZ1cEdEZ00iLCJhbGciOiJSUzI1NiIsIng1dCI6Ik1yNS1BVWliZkJpaTdOZDFqQmViYXhib1hXMCIsImtpZCI6Ik1yNS1BVWliZkJpaTdOZDFqQmViYXhib1hXMCJ9.eyJhdWQiOiJodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vIiwiaXNzIjoiaHR0cHM6Ly9zdHMud2luZG93cy5uZXQvYTUxZDgyNzYtYThjYS00NmEyLTg3NjUtYjE2ZjJmN2U1ZTZhLyIsImlhdCI6MTY0NDY3NjYzMiwibmJmIjoxNjQ0Njc2NjMyLCJleHAiOjE2NDQ2ODE5MzYsImFjY3QiOjAsImFjciI6IjEiLCJhaW8iOiJFMlpnWUJEWWVlYTZXdGlWN01mQ241ZHNXTFNpWlZQeE9nUHVob1ZjQVF6K01UL1pBK0lCIiwiYW1yIjpbInB3ZCJdLCJhcHBfZGlzcGxheW5hbWUiOiJNaWNyb3NvZnQgSW50dW5lIHBvcnRhbCBleHRlbnNpb24iLCJhcHBpZCI6IjU5MjZmYzhlLTMwNGUtNGY1OS04YmVkLTU4Y2E5N2NjMzlhNCIsImFwcGlkYWNyIjoiMiIsImNvbnRyb2xzIjpbImNhX2VuZiJdLCJmYW1pbHlfbmFtZSI6IkhvcmJhY3oiLCJnaXZlbl9uYW1lIjoiTWFjaWVqIiwiaWR0eXAiOiJ1c2VyIiwiaXBhZGRyIjoiODkuNjQuMTE5LjIxNCIsIm5hbWUiOiJNYWNpZWogSG9yYmFjeiIsIm9pZCI6ImNmMWYwNTI1LWQzMjYtNDVmMy1iYTBlLWZkMDhkYjA3OTM0ZSIsInBsYXRmIjoiMyIsInB1aWQiOiIxMDAzMjAwMDk2M0IwMzQ0IiwicmgiOiIwLkFVY0Fkb0lkcGNxb29rYUhaYkZ2TDM1ZWFnTUFBQUFBQUFBQXdBQUFBQUFBQUFCSEFMMC4iLCJzY3AiOiJDbG91ZFBDLlJlYWQuQWxsIENsb3VkUEMuUmVhZFdyaXRlLkFsbCBEZXZpY2VNYW5hZ2VtZW50QXBwcy5SZWFkV3JpdGUuQWxsIERldmljZU1hbmFnZW1lbnRDb25maWd1cmF0aW9uLlJlYWRXcml0ZS5BbGwgRGV2aWNlTWFuYWdlbWVudE1hbmFnZWREZXZpY2VzLlByaXZpbGVnZWRPcGVyYXRpb25zLkFsbCBEZXZpY2VNYW5hZ2VtZW50TWFuYWdlZERldmljZXMuUmVhZFdyaXRlLkFsbCBEZXZpY2VNYW5hZ2VtZW50UkJBQy5SZWFkV3JpdGUuQWxsIERldmljZU1hbmFnZW1lbnRTZXJ2aWNlQ29uZmlndXJhdGlvbi5SZWFkV3JpdGUuQWxsIERpcmVjdG9yeS5BY2Nlc3NBc1VzZXIuQWxsIGVtYWlsIG9wZW5pZCBwcm9maWxlIFNpdGVzLlJlYWQuQWxsIiwic3ViIjoiNkw5Q1hJeTRsckJPMGZ3RGVIaldCMDZUOGtLOXVBT3c2UnhLS0VYLTN0OCIsInRlbmFudF9yZWdpb25fc2NvcGUiOiJFVSIsInRpZCI6ImE1MWQ4Mjc2LWE4Y2EtNDZhMi04NzY1LWIxNmYyZjdlNWU2YSIsInVuaXF1ZV9uYW1lIjoibWFjaWVqaG9yYmFjekBkdW5lc2JveC5vbm1pY3Jvc29mdC5jb20iLCJ1cG4iOiJtYWNpZWpob3JiYWN6QGR1bmVzYm94Lm9ubWljcm9zb2Z0LmNvbSIsInV0aSI6ImllckFtVU9WMlVHQUd0c1RwdllQQUEiLCJ2ZXIiOiIxLjAiLCJ3aWRzIjpbImUzOTczYmRmLTQ5ODctNDlhZS04MzdhLWJhOGUyMzFjNzI4NiIsIjYyZTkwMzk0LTY5ZjUtNDIzNy05MTkwLTAxMjE3NzE0NWUxMCIsImU4NjExYWI4LWMxODktNDZlOC05NGUxLTYwMjEzYWIxZjgxNCIsImIwZjU0NjYxLTJkNzQtNGM1MC1hZmEzLTFlYzgwM2YxMmVmZSIsIjE5NGFlNGNiLWIxMjYtNDBiMi1iZDViLTYwOTFiMzgwOTc3ZCIsImI3OWZiZjRkLTNlZjktNDY4OS04MTQzLTc2YjE5NGU4NTUwOSJdLCJ4bXNfc3QiOnsic3ViIjoialU1SWVqSGU5MVpjcDlKdHZLNXV3aWJBN0d5SHZfRjUyMzJqa1dZdUFWYyJ9LCJ4bXNfdGNkdCI6MTU3OTI5NzMxNH0.SuWFMS0iGwVZkM_R1zdRMxOIE3N5Mjf2CQOom_0NHh3yKyS_Gl5FxFeeKcsBS8qkWdI7ybBONOLuoebGlLX69PyjTRnlqob8vHSe3h6DiSMwvMAuTE3GQ0yYMM-EMfN96gHIaDargVjknWb48k7CeQuS5b4I8aNuze-yhItZz0jSthucUXmQQtKWEvyh_HvQdcWMOGbYGaBCZDaTSoocek2FUh4bVli_bhfOkBSC2ZNRTXaZ0jvw27Giw3AB8wd70gPjKHKH-RsUmLhdlqdFGxWwX5sYZ_6JY2yTfIIDiZfVN8OpbyosG6XuUDPt02S\"   \"x-ms-effective-locale\"=\"en.pl-pl\"   \"Accept\"=\"*/*\"   \"Referer\"=\"\"   \"x-ms-client-request-id\"=\"6e90a57a-1cdd-4bbd-992c-991a561319bb\"   \"client-request-id\"=\"6e90a57a-1cdd-4bbd-992c-991a561319bb\" } ` -ContentType \"application/json\" ` -Body \"{`\"name`\":`\"Edge`\",`\"description`\":`\"`\",`\"platforms`\":`\"windows10`\",`\"technologies`\":`\"mdm`\",`\"roleScopeTagIds`\":[`\"0`\"],`\"settings`\":[{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationSetting`\",`\"settingInstance`\":{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance`\",`\"settingDefinitionId`\":`\"device_vendor_msft_policy_config_microsoft_edge~policy~microsoft_edge~startup_restoreonstartup`\",`\"choiceSettingValue`\":{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationChoiceSettingValue`\",`\"value`\":`\"device_vendor_msft_policy_config_microsoft_edge~policy~microsoft_edge~startup_restoreonstartup_1`\",`\"children`\":[{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance`\",`\"settingDefinitionId`\":`\"device_vendor_msft_policy_config_microsoft_edge~policy~microsoft_edge~startup_restoreonstartup_restoreonstartup`\",`\"choiceSettingValue`\":{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationChoiceSettingValue`\",`\"value`\":`\"device_vendor_msft_policy_config_microsoft_edge~policy~microsoft_edge~startup_restoreonstartup_restoreonstartup_4`\",`\"children`\":[]}}]}}},{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationSetting`\",`\"settingInstance`\":{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance`\",`\"settingDefinitionId`\":`\"device_vendor_msft_policy_config_microsoft_edge~policy~microsoft_edge~startup_restoreonstartupurls`\",`\"choiceSettingValue`\":{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationChoiceSettingValue`\",`\"value`\":`\"device_vendor_msft_policy_config_microsoft_edge~policy~microsoft_edge~startup_restoreonstartupurls_1`\",`\"children`\":[{`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationSimpleSettingCollectionInstance`\",`\"settingDefinitionId`\":`\"device_vendor_msft_policy_config_microsoft_edge~policy~microsoft_edge~startup_restoreonstartupurls_restoreonstartupurlsdesc`\",`\"simpleSettingCollectionValue`\":[{`\"value`\":`\"google.com`\",`\"@odata.type`\":`\"#microsoft.graph.deviceManagementConfigurationStringSettingValue`\"}]}]}}}],`\"templateReference`\":{`\"templateId`\":`\"`\",`\"templateFamily`\":`\"none`\",`\"templateDisplayName`\":null,`\"templateDisplayVersion`\":null}}\"   Change Method to POST‚Ä¶ Now with THAT you can create infinite number of this configuration profile anywhere! ü™Ñ   Only one condition must be met      You need working Authorization token for destination tenant   How to get token? Well that is easy, just sign in to destination tenat and using DevTools trick copy token for that environment and make changes to the code.   Summary   I get shivers thinking that I would have to manualy recreate every single setting I‚Äôve set üòñ   With that I‚Äôve saved a lot of time moving from simple profile to such that contain dozens of policies!!   See you in next! üòâ üß†  ","categories": ["Powershell"],
        "tags": ["Intune","Powershell","MicrosoftEdge"],
        "url": "http://localhost:4000/powershell/SettingsCatalog-Move/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "How to easily move MDM Security Baseline profile",
        "excerpt":"Intro   Hey! My previous post was about moving Settings Catalog profile between MEM tenants - How to easily move Settings Catalog profile    If you found it useful and it helped you save a lot of time this one you will love too ü•∞   Microsoft Security Baselines   What are MDM Security Baselines? üîê   Security baselines are groups of pre-configured Windows (or Edge or Office) settings that help you apply and enforce granular security settings that are recommended by the relevant security teams. You can also customize each baseline you deploy to enforce only those settings and values you require. When you create a security baseline profile in Intune, you‚Äôre creating a template that consists of multiple device configuration profiles.   This feature applies to:      Windows 10 version 1809 and later   Windows 11   You deploy security baselines to groups of users or devices in Intune, and the settings apply to devices that run Windows 10/11. For example, the MDM Security Baseline automatically enables BitLocker for removable drives, automatically requires a password to unlock a device, automatically disables basic authentication, and more. When a default value doesn‚Äôt work for your environment, customize the baseline to apply the settings you need.   Read more   To create a new baseline for your organization go to MEM portal      Choose baseline area (let‚Äôs stick with Win 10)         Enter profile name, description and continue.   For presentation purposes I‚Äôve changed one setting and the rest is left as Microsoft recommends.      Assign profile      In summary you will see only the list of settings that are changed. So if you take baseline ‚Äòas is‚Äô then no setting will be listed in summary.         Read profile settings   As I described in previous post, Settings Catalog profile details are stored in body of request whenever you edit or create it.   Check here   MDM Security baseline MS Graph requests works a little bit different. Thanks to almighty üí™ Edge DevTools I was able to figure it out!   First of all you need to get all settings categories from security baseline template.   $Categories = Invoke-RestMethod -UseBasicParsing -Uri 'https://graph.microsoft.com/beta/deviceManagement/templates/034ccd46-190c-4afc-adf1-ad7cc11262eb/categories'   -WebSession $session `   -Headers $Header    With this now you will be able to read values for each setting in discovered categories. You need:      Intent ID - MDM Security baseline profile GUID   Category ID - GUID of category from code above   Using this simple loop you will read entire baseline profile which later can be used as an input for create/update request.   # YOUR PROFILE GUID $Intent = '1c2097b1-409b-4a95-8654-cb1bdd8ca7c5'  $Settings = foreach ($Setting in $Categories.value) {     $SettingInstanceValues = Invoke-RestMethod -UseBasicParsing -Uri \"https://graph.microsoft.com/beta/deviceManagement/intents/$Intent/categories/$($Setting.id)/settings?`$expand=Microsoft.Graph.DeviceManagementComplexSettingInstance/Value\" `         -WebSession $session `         -Headers $Header      foreach ($SettingValue in $SettingInstanceValues.value) {         $SettingValue     } }   Now we have values for every single setting within Windows 10 MDM Security Baseline! üòéüéâ   Move MDM Security Baseline profile   When creating or updating MDM Security Baseline profile in Body of request you need to specify list of settings and values you wish to set.   First step we‚Äôve got covered - read security baseline profile (from test tenant üòâ)   Second step create production profile:   #Create a new profile $SettingsJSON = $Settings | ConvertTo-Json -Depth 99 $ProfileName = 'Global_Win10'  $Create = Invoke-RestMethod -UseBasicParsing -Uri 'https://graph.microsoft.com/beta/deviceManagement/templates/034ccd46-190c-4afc-adf1-ad7cc11262eb/createInstance' `  -Method 'POST' `  -WebSession $session `  -Headers $Header `  -ContentType 'application/json' `  -Body \"{`\"displayName`\":`\"$ProfileName`\",`\"description`\":`\"`\",`\"settingsDelta`\":$SettingsJSON,`\"roleScopeTagIds`\":[`\"0`\"]}\"    or update existing:   #Update profile $SettingsJSON = $Settings | ConvertTo-Json -Depth 99 $IntentID = '1c2097b1-409b-4a95-8654-cb1bdd8ca7c5'  $ApplySettings = Invoke-RestMethod -UseBasicParsing -Uri \"https://graph.microsoft.com/beta/deviceManagement/intents/$IntentID/updateSettings\" `   -Method 'POST' `   -WebSession $session `   -Headers $Header `   -ContentType 'application/json' `   -Body \"{`\"settings`\":$SettingsJSON}\"   And that‚Äôs it!! ü™Ñü§ùüòÅ   Summary   With this and previous post I feel more and more confidence that Infrastructure as Code in regards of Intune configurations is project that I should look into.   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Intune","Powershell","MicrosoftEdge"],
        "url": "http://localhost:4000/intune/IntuneSecurityBaseline-Move/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Export, Fix, Import - Settings Catalog",
        "excerpt":"Intro   Hi there!   In this post I‚Äôd like to share how to read Settings Catalog profile with Powershell, convert it to digestible JSON format that will allow you to import it back to your tenant or every other!   Export   At this moment the only option to export any Intune configuration is to use Microsoft Graph. Additionally Settings Catalog profiles can be duplicated ü™Ñ.   But why if you would like to create local copy of profiles or move them to another tenant?   I‚Äôve already done post on fast and easy way to move Settings Catalog using Microsoft Edge and Powershell. Read more‚Ä¶   Fristly we need id‚Äôs of profiles so let‚Äôs get that   $params = @{     #Microsoft Intune Powershell     ClientId = 'd1ddf0e4-d672-4dae-b554-9d5bdfd93547'     TenantId = 'YOURTENANTNAME.onmicrosoft.com'     DeviceCode = $true } $authHeaders = @{Authorization = (Get-MsalToken @params).CreateAuthorizationHeader()}  $restParam = @{     Method      = 'Get'     Uri         = 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'     Headers     = $authHeaders     ContentType = 'Application/json' }  $configPolicies = Invoke-RestMethod @restParam $configPolicies.value    That‚Äôs easy and painless üòä      Now that we have that list we can iterate through it to get details of every policy.   $configPoliciesDetails = foreach ($Policy in $configPolicies.value) {     $restParam = @{         Method      = 'Get'         Uri         = \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('$($Policy.id)')/settings?`$expand=settingDefinitions&amp;top=1000\"         Headers     = $authHeaders         ContentType = 'Application/json'     }     Invoke-RestMethod @restParam }      To make our policies useable down the pipeline we need to rebuild it into compatible JSON form (ÔΩûÔø£‚ñΩÔø£)ÔΩû   Fix   To make it work you need to create JSON object that follow strick format.   Thankfuly throught Powershell that‚Äôs easy!   $configPoliciesFormatted = foreach ($Policy in $configPolicies.value) {     $restParam = @{         Method      = 'Get'         Uri         = \"https://graph.microsoft.com/beta/deviceManagement/configurationPolicies('$($Policy.id)')/settings?`$expand=settingDefinitions&amp;top=1000\"         Headers     = $authHeaders         ContentType = 'Application/json'     }     $PolicyDetails = Invoke-RestMethod @restParam      [PSCustomObject]@{         name            = $configPolicies.value.name         description     = $configPolicies.value.description         platforms       = $configPolicies.value.platforms         technologies    = $configPolicies.value.technologies         roleScopeTagIds = @($configPolicies.value.roleScopeTagIds)         settings        = @(@{'settingInstance' = $configPoliciesDetails.value.settinginstance })     } }  $PolicyJSON = $configPoliciesFormatted | ConvertTo-Json -Depth 99   Now we have exported profile ready to be imported. Below you can find example how it should look like:   {     \"name\": \"MDMWinOverGPO\",     \"description\": \"\",     \"platforms\": \"windows10\",     \"technologies\": \"mdm\",     \"roleScopeTagIds\": [         \"0\"     ],     \"settings\": [         {             \"settingInstance\": {                 \"@odata.type\": \"#microsoft.graph.deviceManagementConfigurationChoiceSettingInstance\",                 \"settingDefinitionId\": \"device_vendor_msft_policy_config_controlpolicyconflict_mdmwinsovergp\",                 \"settingInstanceTemplateReference\": null,                 \"choiceSettingValue\": {                     \"settingValueTemplateReference\": null,                     \"value\": \"device_vendor_msft_policy_config_controlpolicyconflict_mdmwinsovergp_1\",                     \"children\": []                 }             }         }     ] }   Import   Depending on your need you will be passing JSON body straight from Powershell session cache or from file and that‚Äôs totally up to you.   To create new Settings Catalog policy just grab your profile body and pass it to POST request    $restParam = @{     Method      = 'Post'     Uri         = 'https://graph.microsoft.com/beta/deviceManagement/configurationPolicies'     Headers     = $authHeaders     ContentType = 'Application/json'     Body        = $PolicyJSON }  $NewConfigPolicy = Invoke-RestMethod @restParam    Summary   I‚Äôve provided RAW materials for you to build your functions over those. Everyone has their unique set of needs so I hope that this post will jump start your journey with Settings Catalog and PowerShell!   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Powershell","Intune"],
        "url": "http://localhost:4000/intune/SettingsCatalog-PowerShell/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      },{
        "title": "Truly user-driven Windows Autopilot",
        "excerpt":"Intro   Hi there!   A colleague of mine came to me with question ‚ÄòCan we somehow make the Windows Autopilot dependent on the user account that starts it?‚Äô. The reason behind that was to try ditching Windows Autopilot device group tags and latency of Azure AD dynamic groups.   Immediately an idea came to my head üí°!   Configuration profiles assignment   Windows Autopilot has two deployment scenarios:      Azure AD join if devices don‚Äôt need to join an on-premises Active Directory domain.   Hybrid Azure AD join for devices that need to join both Azure AD and your on-premises Active Directory domain.   While AAD join is quick and easy, HAAD join is more complex and beside deployment profile device requires domain join profile assigned.   With the use of group tags IT Admins (or vendors depend if device hash was uploaded in factory) can predetermine configuration for the device before even deployment starts.   Using group tags to import devices into Intune with Autopilot   Speaking of domain join profile      There is not much but what if your company has multiple domains?   Well you can‚Äôt type in more than one into the profile and if you create multiple profiles the first one to come will be used. That is why group tags will help with assigning only that which should be used. But again this needs to determined before Autopilot deployment even starts.   Idea is to join device to the same domain as the user that started deployment. How about assigning domain join profile to the user?! ü§î         What if there was another way‚Ä¶   PowerShell + Graph API      Source - oofhours   Based on that flowchart and my experience after device is enrolled to Intune configuration policies are applied and domain join profile with them. If the latter is missing device waits up to 25-30 minutes until failing entire process. That gives us time to run PowerShell runbook which will assign groups based on the user that started Autopilot!   For this to happen you need Azure Automation instance and service principal with the following set of permissions         NOTE: Service Princial doesn‚Äôt have to have right to manage group membership. It just needs to be owner of the groups that it will change üòé    For more info on how to create azure automation and how to use service principal visit my previous post -  here   To easily find only newly enrolled devices to Intune you can make a Graph call to deviceManagement/managedDevices with filter enrolleddatetime      $DateTimeNow = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK') $DateTimeNowM10 = (Get-Date).addhours(-2).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK') $Resource = \"deviceManagement/managedDevices?`$filter=(Notes%20eq%20%27bc3e5c73-e224-4e63-9b2b-0c36784b7e80%27)%20and%20((enrolleddatetime%20lt%20$DateTimeNow)%20and%20(enrolleddatetime%20gt%20$DateTimeNowM10)%20and%20((deviceType%20eq%20%27desktop%27)%20or%20(deviceType%20eq%20%27windowsRT%27)))&amp;`$top=25&amp;`$skipToken=Skip=%270%27&amp;`$select=deviceName,managementAgent,ownerType,complianceState,deviceType,userId,userPrincipalName,osVersion,lastSyncDateTime,userPrincipalName,id,deviceRegistrationState,managementState,exchangeAccessState,exchangeAccessStateReason,deviceActionResults,deviceEnrollmentType\" Write-Output \"Time: $DateTimeNow\" $APICallParams = @{     Method  = 'GET'     Headers = $AuthorizationToken     Uri     = \"$GraphUrl/$GraphVersion/$Resource\" }  Write-Output 'Checking for Windows Autopilot new devices...' $WindowsAutopilotEnrolledDevices = (Invoke-RestMethod @APICallParams).value   That way you will also get userPrincipalName of the user that started deployment!   To make assignment of the configuration profiles based on the user I came up with a design to have two groups:      One for the users and another with resembling name for the devices where devices group is assigned to the domain join profile in Intune      With just another API call we get user membership   $APICallParams = @{     Method  = 'GET'     Headers = $AuthorizationToken     Uri     = \"$GraphUrl/$GraphVersion/users/$($Device.userid)/memberOf\" } $UserGroups = (Invoke-RestMethod @APICallParams).value $DeviceGroupsFromUserGroups = $UserGroups.Where({ $PSItem.displayName -like '*-Users_AzA' })   Later on user group names are transformed to device groups and to proceed further we need group object ID   $DeviceGroup = \"$($DeviceGroup.displayName.split('-')[0])-Computers\" $RequestSplat = @{     Headers = $AuthorizationToken + @{'ConsistencyLevel' = 'eventual' }     Uri     = \"$GraphUrl/$GraphVersion/groups?`$filter=displayname eq '$DeviceGroup'\" } $AADGroupObject = (Invoke-RestMethod @RequestSplat).value   To assign Azure AD group to the Azure AD device object you also need device object id which should not be confused with device id         #Get Intune device details $APICallParams = @{     Method  = 'GET'     Headers = $AuthorizationToken     Uri     = \"$GraphUrl/$GraphVersion/deviceManagement/manageddevices('$($Device.id)')\" } $IntuneDeviceDetails = Invoke-RestMethod @APICallParams  #Get AAD object from Intune object $RequestSplat = @{     Headers = $AuthorizationToken + @{'ConsistencyLevel' = 'eventual' }     Uri     = \"$GraphUrl/$GraphVersion/devices?`$filter=deviceId eq '$($IntuneDeviceDetails.azureADDeviceId)' or id eq '$($IntuneDeviceDetails.azureADDeviceId)'\" } $AADDeviceObject = (Invoke-RestMethod @RequestSplat).value   That was the last piece of our puzzle. Now you can proceed with adding Autopilot device to Azure AD group that will apply domain join profile policy   $APICallParams = @{     Uri     = \"$GraphUrl/$GraphVersion/groups/$($AADGroupObject.id)/members/`$ref\"     Body    = @{         '@odata.id' = \"$GraphUrl/$GraphVersion/devices/$($AADDeviceObject.id)\"     } | ConvertTo-Json     Method  = 'POST'     Headers = $AuthorizationToken + @{'Content-Type' = 'application/json' } } Invoke-RestMethod @APICallParams      The whole script looks as follows:   Set-Item Env:\\SupressAzurePowerShellBreakingChangeWarnings 'true' $Global:ErrorActionPreference = 'Stop' [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12  $Autopilot_UserGroups_Connection = Get-AutomationPSCredential -Name 'CREDENTIAL_NAME'  $Token = Get-MsalToken -ClientId $Autopilot_UserGroups_Connection.UserName -ClientSecret $Autopilot_UserGroups_Connection.Password -TenantId 'YOUR TENANT ID' $AuthorizationToken = @{Authorization = \"Bearer $($Token.AccessToken)\" }  $GraphUrl = 'https://graph.microsoft.com' $GraphVersion = 'beta' $DateTimeNow = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK') $DateTimeNowM10 = (Get-Date).addhours(-2).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ss.fffK') $Resource = \"deviceManagement/managedDevices?`$filter=(Notes%20eq%20%27bc3e5c73-e224-4e63-9b2b-0c36784b7e80%27)%20and%20((enrolleddatetime%20lt%20$DateTimeNow)%20and%20(enrolleddatetime%20gt%20$DateTimeNowM10)%20and%20((deviceType%20eq%20%27desktop%27)%20or%20(deviceType%20eq%20%27windowsRT%27)))&amp;`$top=25&amp;`$skipToken=Skip=%270%27&amp;`$select=deviceName,managementAgent,ownerType,complianceState,deviceType,userId,userPrincipalName,osVersion,lastSyncDateTime,userPrincipalName,id,deviceRegistrationState,managementState,exchangeAccessState,exchangeAccessStateReason,deviceActionResults,deviceEnrollmentType\" Write-Output \"Time: $DateTimeNow\" $APICallParams = @{     Method  = 'GET'     Headers = $AuthorizationToken     Uri     = \"$GraphUrl/$GraphVersion/$Resource\" }  Write-Output 'Checking for Windows Autopilot new devices...' try {     $WindowsAutopilotEnrolledDevices = (Invoke-RestMethod @APICallParams).value     $WindowsAutopilotDevicesCount = $($($WindowsAutopilotEnrolledDevices | Measure-Object).Count)     if ($WindowsAutopilotDevicesCount -eq 0) {         Write-Warning 'No new Autopilot devices found'         Write-Warning 'Terminating script'     } else {         Write-Output \"$WindowsAutopilotDevicesCount found\"         foreach ($Device in $WindowsAutopilotEnrolledDevices) {             Write-Output \"Processing $($Device.DeviceName)\"              #Get AAD User details             if ($null -eq $Device.userid -or $Device.userId -eq '') {                 Write-Warning 'Device user is null!!'                 Write-Warning 'Skipping Device'                 Continue             } else {                 $APICallParams = @{                     Method  = 'GET'                     Headers = $AuthorizationToken                     Uri     = \"$GraphUrl/$GraphVersion/users/$($Device.userid)/memberOf\"                 }                 $UserGroups = (Invoke-RestMethod @APICallParams).value                 $DeviceGroupsFromUserGroups = $UserGroups.Where({ $PSItem.displayName -like '*-Users_AzA' })             }             if ($null -eq $DeviceGroupsFromUserGroups) {                 Write-Warning \"$($Device.userDisplayName) has no Users_AzA groups!\"                 Write-Warning 'Skipping Device'                 Continue             }                 foreach ($DeviceGroup in $DeviceGroupsFromUserGroups) {                 #Get device group ID                 $DeviceGroup = \"$($DeviceGroup.displayName.split('-')[0])-Computers\"                 $RequestSplat = @{                     Headers = $AuthorizationToken + @{'ConsistencyLevel' = 'eventual' }                     Uri     = \"$GraphUrl/$GraphVersion/groups?`$filter=displayname eq '$DeviceGroup'\"                 }                 $AADGroupObject = (Invoke-RestMethod @RequestSplat).value                  #Get AAD group members                 $APICallParams = @{                     Method  = 'GET'                     Headers = $AuthorizationToken                     Uri     = \"$GraphUrl/$GraphVersion/groups/$($AADGroupObject.id)/members\"                 }                 $GroupMembers = (Invoke-RestMethod @APICallParams).value                              #Get Intune device details                 $APICallParams = @{                     Method  = 'GET'                     Headers = $AuthorizationToken                     Uri     = \"$GraphUrl/$GraphVersion/deviceManagement/manageddevices('$($Device.id)')\"                 }                 $IntuneDeviceDetails = Invoke-RestMethod @APICallParams                              #Get AAD object from Intune object                 $RequestSplat = @{                     Headers = $AuthorizationToken + @{'ConsistencyLevel' = 'eventual' }                     Uri     = \"$GraphUrl/$GraphVersion/devices?`$filter=deviceId eq '$($IntuneDeviceDetails.azureADDeviceId)' or id eq '$($IntuneDeviceDetails.azureADDeviceId)'\"                 }                 $AADDeviceObject = (Invoke-RestMethod @RequestSplat).value                              if ($GroupMembers.id -notcontains $AADDeviceObject.id) {                                      $APICallParams = @{                         Uri     = \"$GraphUrl/$GraphVersion/groups/$($AADGroupObject.id)/members/`$ref\"                         Body    = @{                             '@odata.id' = \"$GraphUrl/$GraphVersion/devices/$($AADDeviceObject.id)\"                         } | ConvertTo-Json                         Method  = 'POST'                         Headers = $AuthorizationToken + @{'Content-Type' = 'application/json' }                     }                     Invoke-RestMethod @APICallParams                     Write-Output \"Device - $($AADDeviceObject.displayName) added as a member\"                 } else {                     Write-Warning \"Device - $($AADDeviceObject.displayName) already a member\"                 }             }         }     } } catch {     Write-Error \"         ScriptLineNumber $($_.InvocationInfo.ScriptLineNumber)         OffsetInLine $($_.InvocationInfo.OffsetInLine)\"     $ex = $_.Exception     $errorResponse = $ex.Response.GetResponseStream()     $reader = New-Object System.IO.StreamReader($errorResponse)     $reader.BaseStream.Position = 0     $reader.DiscardBufferedData()     $responseBody = $reader.ReadToEnd();     Write-Error \"Response content: $responseBody\"     Write-Error \"Request to $Uri failed with HTTP Status $($ex.Response.StatusCode) $($ex.Response.StatusDescription)\" }      Autopilot in action   User unboxes device, connects it to the Internet and deployment profile is downloaded. After authenticating with work account device is enrolled into Intune.      Then configuration profiles are applied and device object is created in Intune.      Device will wait around 25-30 minutes for domain join profile.      When profile arrives and ODJ request is raised then device is renamed.      Deployment will continue after reboot      Then the rest of configurations are applied      After ESP user can sign-in using domain credentials      And that is it!   Summary   Described process is a little bit risky due to possible latency of runbook schedule, Azure group membership sync, device sync with Intune, etc.   But unless there will be some other way to archive the result of building devices based on the user account it seems like using PowerShell and Graph is the easiest and coolest option.   See you in next! üòâ üß†  ","categories": ["Intune"],
        "tags": ["Powershell","Windows Autopilot","Azure Automation","Microsoft Graph","Intune"],
        "url": "http://localhost:4000/intune/User-driven-Autopilot/",
        "teaser": "http://localhost:4000/assets/head_image_sized.png"
      }]
